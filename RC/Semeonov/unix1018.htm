<HTML><HEAD>
<!-- Meta http equivalent was here                                     -->
<META NAME="keywords" CONTENT="UNIX





">
<TITLE>10.18 Краткий справочник по командам UNIX</TITLE>
</HEAD>
<BODY background="gainsboro" tppabs="http://book.itep.ru/gainsboro" link="#0000FF">

<center>
<table BORDER="0" CELLSPACING="1" CELLPADDING="5" bgcolor="ghostwhite">
  <tr>
    <td VALIGN="TOP" bgcolor="steelblue" LINK="#0000FF"><p align="center">

<A HREF="cab_1017.htm" tppabs="http://book.itep.ru/10/cab_1017.htm">  <IMG ALIGN=BOTTOM ALT="previous" SRC="k_prev.jpg" tppabs="http://book.itep.ru/k_prev.jpg"></A>


<A HREF="adr_1011.htm" tppabs="http://book.itep.ru/10/adr_1011.htm">   <IMG ALIGN=BOTTOM ALT="up"   SRC="k_up.jpg" tppabs="http://book.itep.ru/k_up.jpg"></A>



<A HREF="html1019.htm" tppabs="http://book.itep.ru/10/html1019.htm"><IMG ALIGN=BOTTOM ALT="next" SRC="k_next.jpg" tppabs="http://book.itep.ru/k_next.jpg"></A>

<A HREF="intro1.htm" tppabs="http://book.itep.ru/1/intro1.htm">  <IMG ALIGN=BOTTOM ALT="index" SRC="k_indx.jpg" tppabs="http://book.itep.ru/k_indx.jpg"></A>
<BR>

<B> <FONT COLOR="white">Previous: </FONT></B>
<A HREF="cab_1017.htm" tppabs="http://book.itep.ru/10/cab_1017.htm"><FONT COLOR="lightblue">10.17 Разводка разъемов</FONT></A>


<B><FONT COLOR="white">&nbsp;&nbsp; UP:</FONT> </B>
<A HREF="adr_1011.htm" tppabs="http://book.itep.ru/10/adr_1011.htm"><FONT COLOR="lightblue">10.11 Адреса    серверов ведущих фирм, работающих в сфере телекоммуникаций</FONT></A>
<BR>



<B><FONT COLOR="white">&nbsp; &nbsp; Next:</FONT></B>
<A HREF="html1019.htm" tppabs="http://book.itep.ru/10/html1019.htm"><FONT COLOR="lightblue">10.19 Символьный набор HTML</FONT></A>

</TD></TR>
<TR><TD ALIGN=CENTER>   
<FONT color="#0000FF" size=6><B>10.18 Краткий справочник по командам UNIX</B></FONT><br>
<FONT size=3>Семенов Ю.А. (ГНЦ ИТЭФ)</FONT></p>

</TD></TR>
<TR><TD>
<!--new-->
<P ALIGN="JUSTIFY">Первая версия UNIX была создана в 1971 году, в 1979 году была подготовлена 7-я 
редакция (Bourne Shell и компилятор С, разработанная Керниганом и Ритчи; тогда же фирма Microsoft купила 
права и разработала свою версию для РС - XENIX). Первая версия BSD (Беркли) была подготовлена в 1978 
году. В 1981 году закончена версия, поддерживающая стек протоколов TCP/IP (4.2BSD). В 1990 году в UNIX 
была встроена система NFS. Несколько лет назад в университете Хельсинки (Линусом Торвальдсом) была 
разработана версия UNIX, известная под названием LINUX.</P>

<P ALIGN="JUSTIFY">UNIX имеет двухуровневую структуру: ядро, где сконцентрированы базовые услуги и 
оболочка, куда входят редакторы, интерпретаторы, например СС, а также <B>lp, routed, inetd, init </B>
и т.д.</P>
<P ALIGN="JUSTIFY">Код UNIX написан на Си (на 30% больше по объему и на 20% ниже по производительности, 
чем версия на ассемблере). Система открытая, рассчитанная на многозадачность и большое число 
пользователей.</P>

<P ALIGN="JUSTIFY">Интерфейс системных вызовов предоставляет набор услуг ядра и определяет формат 
запросов. Ядро состоит из трех частей:</P>

<OL><LI>Файловая система</LI>
<LI>Система управления процессами и памятью</LI>
<LI>Система ввода/вывода.</LI></OL>

<B><I><P ALIGN="JUSTIFY">Файловая система</B></I> обеспечивает интерфейс доступа к данным на дисковых 
накопителях и в периферийных устройствах ввода/вывода. Одни и те же функции open(), read(0, write() могут 
использоваться при чтении/записи на диске и при выводе данных на принтер или терминал. Файловая система 
управляет правами доступа и привилегиями. Она обеспечивает перенаправление запросов, адресованных 
периферийным устройствам.</P>

<B><I><P ALIGN="JUSTIFY">Система управления процессами</B></I> ЭВМ, причем их число обычно превышает 
число ЦПУ. Специальной задачей ядра является планирование выполнением процессов (scheduler). Сюда входит 
управление ресурсами системы (временем ЦПУ, дисковым пространством, распределением памяти и т.д.). Данная 
система занимается созданием и удалением процессов, синхронизацией их работы и взаимодействием процессов 
(например, обменом данными).</P>

<B><I><P ALIGN="JUSTIFY">Система ввода/вывода</B></I> обслуживает запросы файловой системы и системы 
управления процессами для доступа к периферийным устройствам (дискам, лентам, печати, терминалам). Эта 
система организует взаимодействие с драйверами этих устройств.</P>

<P ALIGN="JUSTIFY">Файловая система UNIX представляет собой древовидную структуру. Каждый файл имеет имя, 
которое определяет его место на дереве файловой системы. Корнем этой системы является корневой каталог с 
именем /.</P>

<P ALIGN="JUSTIFY">В этом каталоге обычно содержатся каталоги:</P>

<CENTER><TABLE CELLSPACING=0 BORDER=10 CELLPADDING=3 WIDTH=750 bgcolor="ghostwhite">
<TR><TD WIDTH="15%" VALIGN="TOP"><B><P ALIGN="JUSTIFY">/bin</B></TD>
<TD WIDTH="85%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Каталог наиболее популярных системных команд и утилит.</TD>
</TR>
<TR><TD WIDTH="15%" VALIGN="TOP"><B><P ALIGN="JUSTIFY">/dev</B></TD>
<TD WIDTH="85%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Каталог файлов для периферийных устройств, например дисковых накопителей (/dev/cdrom, 
/dev/mem, /dev/null или /dev/ttyp10).</TD>
</TR>
<TR><TD WIDTH="15%" VALIGN="TOP"><B><P ALIGN="JUSTIFY">/etc</B></TD>
<TD WIDTH="85%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Здесь находятся конфигурационные файлы и утилиты администрирования, среди них скрипты 
инициализации системы.</TD>
</TR>
<TR><TD WIDTH="15%" VALIGN="TOP"><B><P ALIGN="JUSTIFY">/lib</B></TD>
<TD WIDTH="85%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Каталог библиотечных файлов языка Си и других языков.</TD>
</TR>
<TR><TD WIDTH="15%" VALIGN="TOP"><B><P ALIGN="JUSTIFY">/lost+found</B></TD>
<TD WIDTH="85%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Каталог “потерянных” файлов. Ошибки при неправильном выключении ЭВМ могут привести к 
появлению безымянных файлов (содержимое корректно, но нет ссылок на этот файл ни в одном из каталогов).</TD>
</TR>
<TR><TD WIDTH="15%" VALIGN="TOP"><B><P ALIGN="JUSTIFY">/mnt</B></TD>
<TD WIDTH="85%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Каталог для установления временных связей (монтирования) физических файловых систем с 
корневой системой. Обычно каталог пуст.</TD>
</TR>
<TR><TD WIDTH="15%" VALIGN="TOP"><B><P ALIGN="JUSTIFY">/home</B></TD>
<TD WIDTH="85%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Служит для размещения каталогов пользователей (в прежних версиях для этого служил 
каталог /usr.</TD>
</TR>
<TR><TD WIDTH="15%" VALIGN="TOP"><B><P ALIGN="JUSTIFY">/var</B></TD>
<TD WIDTH="85%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Предназначен для размещения сервисных подкаталогов, например, электронной почты 
(/usr/spool), утилит UNIX (/usr/bin), программ, исполняемых на данной ЭВМ (/usr/local), файлов 
заголовков (/usr/include), системы справочника (/usr/man).</TD>
</TR>
<TR><TD WIDTH="15%" VALIGN="TOP"><B><P ALIGN="JUSTIFY">/tmp</B></TD>
<TD WIDTH="85%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Служит для записи временных файлов.</TD>
</TR>
</TABLE></CENTER>

<P ALIGN="JUSTIFY">Полные имена остальных файлов содержат путь – список каталогов, размещенных между / и 
данным файлом. По этой причине полное имя любого файла начинается с символа / (не содержит в отличие от 
Windows имени диска (например, CD), другого внешнего устройства или удаленной ЭВМ).</P>

<P ALIGN="JUSTIFY">UNIX, тем не менее, не предполагает наличия лишь одной файловой системы. Число таких 
файловых систем в этой ОС не лимитировано, они могут располагаться на одном дисковом накопителе, на 
разных устройствах или даже на разных ЭВМ.</P>

<P ALIGN="JUSTIFY">Каждый файл имеет сопряженные с ним метаданные, записанные в индексных дескрипторах – 
<B>inode</B>. Имя файла является указателем на его метаданные (метаданные не содержат указателя на имя 
файла). Существует 6 типов файлов:</P>

<OL><LI>Обычный файл (regular)</LI>
<LI>Каталог (directory)</LI>
<LI>Файл внешнего устройства</LI>
<LI>Канал с именем (FIFO)</LI>
<LI>Связь (link)</LI>
<LI>socket</LI></OL>

<B><I><P ALIGN="JUSTIFY">Обычный файл</B></I> является наиболее распространенным типом. Для операционной 
системы такой файл представляется простой последовательностью байтов. Интерпретация содержимого такого 
файла находится в зоне ответственности прикладной программы, которая с ним работает.</P>

<B><I><P ALIGN="JUSTIFY">Каталог</B></I> – это файл, содержащий имена находящихся в нем файлов и 
указатели на информацию, позволяющую ОС производить операции над этими файлами. Запись в каталог имеет 
право только ядро. Каталог представляет собой таблицу, каждая запись в которой соответствует некоторому 
файлу.</P>

<B><I><P ALIGN="JUSTIFY">Файл внешнего устройства</B></I> обеспечивает  доступ к этому прибору. UNIX 
различает <I>символьные</I> и <I>блочные</I> файлы. Символьные файлы служат для не буферизованного 
обмена, а блочные предполагают обмен порциями данных фиксированной длины.</P>

<B><I><P ALIGN="JUSTIFY">Каналы с именем</B></I> (FIFO) – это файлы, служащие для связи между 
процессами.</P>

<P ALIGN="JUSTIFY">Файловая система допускает наличие нескольких имен у одного файла. Связь имени файла с 
его метаданными называется жесткой связью. С помощью команды <B><I>ln</B></I> можно создать еще одно имя 
для файла. Особым типом файла является символическая связь, позволяющей косвенно обращаться к файлу. 
Символическая <B><I>связь</B></I> является особым типом файла.</P>

<B><P ALIGN="JUSTIFY">Socket</B> служит для взаимодействия между процессами. Интерфейс socket 
используется, например, для доступа к сети TCP/IP.</P>

<P ALIGN="JUSTIFY">Любой файл имеет двух владельцев – собственно создателя и группу (chown, chgrp и 
chmod). Файл создается не пользователем, а процессом, им запущенным. Атрибуты этого процесс присваиваются 
и файлу (r, w и x). Имеется также несколько дополнительных атрибутов, среди них <B><I>sticky bit</B></I>, 
который требует сохранения образа \исполняемого файла в памяти после завершения его работы. Атрибуты SUID 
и GUID позволяют изменить права пользователя в направлении расширения (до уровня создателя файла) на 
время исполнения данной программы (это используется, например, в случае работы с файлом 
<B><I>/etc/passwd)</B></I>. В случае каталогов sticky bit позволяет стереть только файлы, которыми 
владеет пользователь.</P>

<P ALIGN="JUSTIFY">Различается несколько типов процессов.</P>

<OL><B><LI>Системные процессы</B> являются частью ядра и резидентно размещены в оперативной памяти. Они 
запускаются при инициализации ядра системы. Системными процессами являются, например, kmadaemon 
(диспетчер памяти ядра), shed (диспетчер свопинга), bdfflush (диспетчер кэша), init (прародитель всех 
остальных процессов).</LI>
<B><LI>Демоны</B> – не интерактивные процессы, запускаемые путем загрузки в память соответствующих 
программ и выполняемые в фоновом режиме. Демоны не ассоциируются ни с одним из пользователей (они служат, 
например, для организации терминального ввода, печатающего устройства, сетевого доступа).</LI>
<B><LI>Прикладные процессы </B>– это остальные процессы принадлежащие, как правило, пользователям.</LI></OL>

<P ALIGN="JUSTIFY">Процессы создаются процедурой <B><I>fork</B></I> и характеризуются набором 
атрибутов:</P>

<CENTER><TABLE CELLSPACING=0 BORDER=10 CELLPADDING=3 WIDTH=750 bgcolor="ghostwhite">
<TR><TD WIDTH="28%" VALIGN="TOP"><B><P ALIGN="JUSTIFY">PID</B></TD>
<TD WIDTH="72%" VALIGN="TOP">
<P ALIGN="JUSTIFY">(Process ID) представляет собой уникальное имя процесса (идентификатор нового процесса 
характеризуется большим кодом, чем идентификатор предыдущего). После уничтожения процесса ликвидируется 
и его PID и этот идентификатор может быть присвоен новому процессу.</TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP"><B><P ALIGN="JUSTIFY">PPID</B></TD>
<TD WIDTH="72%" VALIGN="TOP">
<P ALIGN="JUSTIFY">(Parent Process ID) – идентификатор процесса, породившего данный процесс.</TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP"><B><P ALIGN="JUSTIFY">Приоритет процесса</B></TD>
<TD WIDTH="72%" VALIGN="TOP">
<P ALIGN="JUSTIFY">(Nice Number) учитывается планировщиком при определении очередности запуска процессов.</TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP"><B><P ALIGN="JUSTIFY">TTY</B></TD>
<TD WIDTH="72%" VALIGN="TOP">
<P ALIGN="JUSTIFY">псевдотерминал, ассоциированный с процессом. Демоны не имеют псевдотерминала.</TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP"><B><P ALIGN="JUSTIFY">RID</B> (Real ID)</TD>
<TD WIDTH="72%" VALIGN="TOP">
<P ALIGN="JUSTIFY">пользователя, запустившего данный процесс. Эффективный идентификатор (<B>EUID</B>) 
служит для определения прав доступа процесса к системным ресурсам.</TD>
</TR>
</TABLE></CENTER>

<P ALIGN="JUSTIFY">Для запуска задачи процесс должен выполнить системный вызов exec. При этом не 
порождается новый процесс, а код процесса замещается полностью кодом запускаемой программы.</P>
<P ALIGN="JUSTIFY">Так, когда пользователь вводит команду <B>ls</B>, текущий процесс <B>shell</B> 
осуществляет вызов <B>fork</B>, порождая новый процесс – копию <B>shell</B>. Порожденный процесс 
осуществит вызов <B>exec</B>, указав в качестве параметра имя исполняемого файла (<B>ls</B>). <B>Ls</B> 
замещает <B>shell</B>, а по завершении работы процесс уничтожается. </P>
<P ALIGN="JUSTIFY"></P>
<B><P ALIGN="JUSTIFY">Сигналы</P>
</B><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Сигналы служат для того, чтобы передавать от одного процесса к другому или от ядра к 
какому-то процессу, уведомление о происхождении некоторого события. Примером такого события может быть 
нажатие клавиши мышки или нажатие клавиш &lt;Ctrl&gt;&lt;C&gt; 
(SIGINIT)или &lt;Ctrl&gt;&lt;Alt&gt;&lt;Del&gt;.</P>
<P ALIGN="JUSTIFY">Для отправления сигнала служит команда <B>kill pid, </B>где<B> sig_no – </B>номер или 
символическое название сигнала,<B> pid -</B> идентификатор процесса, которому адресован сигнал. Для 
остановки процесса, выполняемого в фоновом режиме можно послать сигнал SIGTERM. Например, kill $!, где 
$! – переменная, где хранится идентификатор процесса (PID), запущенного последним.</P>
<B><P ALIGN="CENTER">Таблица 1.</B>  <B><FONT SIZE=4>Сигналы</FONT></P></B>

<CENTER><TABLE BORDER=10 CELLSPACING=1 CELLPADDING=3 WIDTH=756 bgcolor="ghostwhite">
<TR><TD WIDTH="17%" VALIGN="TOP" bgcolor="gainsboro"><P ALIGN="JUSTIFY">Имя сигнала</TD>
<TD WIDTH="25%" VALIGN="TOP" bgcolor="gainsboro"><P ALIGN="CENTER">Функция по умолчанию</TD>
<TD WIDTH="58%" VALIGN="TOP" bgcolor="gainsboro"><P ALIGN="CENTER">Описание</TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><P ALIGN="JUSTIFY">SIGABRT</TD>
<TD WIDTH="25%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Завершение + ядро</TD>
<TD WIDTH="58%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Результат системного вызова <B>abort</B></TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><P ALIGN="JUSTIFY">SIGALRM</TD>
<TD WIDTH="25%" VALIGN="TOP"><P ALIGN="JUSTIFY">Завершение</TD>
<TD WIDTH="58%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Результат срабатывания таймера, установленного системными вызовом alarm или setitimer</TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><P ALIGN="JUSTIFY">SIGBUS</TD>
<TD WIDTH="25%" VALIGN="TOP"><P ALIGN="JUSTIFY">Завершение + ядро</TD>
<TD WIDTH="58%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Результат аппаратной ошибки. Сигнал посылается при обращении к виртуальному адресу, 
для которого отсутствует соответствующая физическая страница памяти.</TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><P ALIGN="JUSTIFY">SIGCHLD</TD>
<TD WIDTH="25%" VALIGN="TOP"><P ALIGN="JUSTIFY">Игнорирование</TD>
<TD WIDTH="58%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Сообщает родительскому процессу о завершении исполнения дочернего </TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><P ALIGN="JUSTIFY">SIGEGV</TD>
<TD WIDTH="25%" VALIGN="TOP"><P ALIGN="JUSTIFY">Завершение + ядро</TD>
<TD WIDTH="58%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Формируется при попытке обращения к неверному адресу или области памяти, для которой у 
процесса нет привилегий.</TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><P ALIGN="JUSTIFY">SIGFPE</TD>
<TD WIDTH="25%" VALIGN="TOP"><P ALIGN="JUSTIFY">Завершение + ядро</TD>
<TD WIDTH="58%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Сигнал возникает в случае деления на нуль или при переполнении в операциях с плавающей 
запятой.</TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><P ALIGN="JUSTIFY">SIGHUP</TD>
<TD WIDTH="25%" VALIGN="TOP"><P ALIGN="JUSTIFY">Завершение</TD>
<TD WIDTH="58%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Посылается хозяину сессии, связанной с консолью, когда ядро обнаружит, что терминал 
отключился. Сигнал передается всем процессам текущей группы при завершении сессии хозяина. Этот сигнал 
иногда используется для взаимодействия процессов, например, для уведомления демонов о необходимости 
обновления конфигурационных данных.</TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><P ALIGN="JUSTIFY">SIGILL</TD>
<TD WIDTH="25%" VALIGN="TOP"><P ALIGN="JUSTIFY">Завершение + ядро</TD>
<TD WIDTH="58%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Посылается ядром при попытке процесса выполнить недопустимую команду.</TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><P ALIGN="JUSTIFY">SIGINT</TD>
<TD WIDTH="25%" VALIGN="TOP"><P ALIGN="JUSTIFY">Завершение</TD>
<TD WIDTH="58%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Посылается ядром всем процессам при нажатии комбинации клавиш &lt;Del&gt; или 
&lt;Crtl&gt;&lt;C&gt;.</TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><P ALIGN="JUSTIFY">SIGKILL</TD>
<TD WIDTH="25%" VALIGN="TOP"><P ALIGN="JUSTIFY">Завершение</TD>
<TD WIDTH="58%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Сигнал прерывает выполнение процесса. Перехват или игнорирование этого сигнала 
невозможно.</TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><P ALIGN="JUSTIFY">SIGPIPE</TD>
<TD WIDTH="25%" VALIGN="TOP"><P ALIGN="JUSTIFY">Завершение</TD>
<TD WIDTH="58%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Результат попытки записи в канал или сокет, когда получатель данных закрыл 
соответствующий дескриптор.</TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><P ALIGN="JUSTIFY">SIGPOLL</TD>
<TD WIDTH="25%" VALIGN="TOP"><P ALIGN="JUSTIFY">Завершение</TD>
<TD WIDTH="58%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Результат реализации определенного события для устройства, которое опрашивается.</TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><P ALIGN="JUSTIFY">SIGPWR</TD>
<TD WIDTH="25%" VALIGN="TOP"><P ALIGN="JUSTIFY">Игнорирование</TD>
<TD WIDTH="58%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Результат угрозы потери питания (при переключении на UPS).</TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><P ALIGN="JUSTIFY">SIGQUIT</TD>
<TD WIDTH="25%" VALIGN="TOP"><P ALIGN="JUSTIFY">Завершение + ядро</TD>
<TD WIDTH="58%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Посылается ядром всем процессам текущей группы при нажатии клавиш &lt;Crtl&gt;&lt;\&gt;.</TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><P ALIGN="JUSTIFY">SIGSTOP</TD>
<TD WIDTH="25%" VALIGN="TOP"><P ALIGN="JUSTIFY">Стоп</TD>
<TD WIDTH="58%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Посылается всем процессам текущей группы при нажатии пользователем комбинации клавиш 
&lt;Crtl&gt;&lt;Z&gt;. Процесс останавливается.</TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><P ALIGN="JUSTIFY">SIGSYS</TD>
<TD WIDTH="25%" VALIGN="TOP"><P ALIGN="JUSTIFY">Завершение + ядро</TD>
<TD WIDTH="58%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Посылается ядром при попытке некорректного системного вызова</TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><P ALIGN="JUSTIFY">SIGTERM</TD>
<TD WIDTH="25%" VALIGN="TOP"><P ALIGN="JUSTIFY">Завершение</TD>
<TD WIDTH="58%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Предупреждение о скорой ликвидации процесса (ликвидировать временные файлы, прервать 
текущие обмены) Команда kill посылает именно этот сигнал.</TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><P ALIGN="JUSTIFY">SIGTTIN</TD>
<TD WIDTH="25%" VALIGN="TOP"><P ALIGN="JUSTIFY">Стоп</TD>
<TD WIDTH="58%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Формируется ядром при попытке фонового процесса выполнить чтение с консоли.</TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><P ALIGN="JUSTIFY">SIGTTOU</TD>
<TD WIDTH="25%" VALIGN="TOP"><P ALIGN="JUSTIFY">Стоп</TD>
<TD WIDTH="58%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Формируется ядром при попытке фонового процесса выполнить запись в консоль</TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><P ALIGN="JUSTIFY">SIGUSR1</TD>
<TD WIDTH="25%" VALIGN="TOP"><P ALIGN="JUSTIFY">Завершение</TD>
<TD WIDTH="58%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Предназначен для прикладных задач, как средство взаимодействия процессов.</TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><P ALIGN="JUSTIFY">SIGUSR2</TD>
<TD WIDTH="25%" VALIGN="TOP"><P ALIGN="JUSTIFY">Завершение</TD>
<TD WIDTH="58%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Предназначен для прикладных задач, как средство взаимодействия процессов.</TD>
</TR>
</TABLE></CENTER>

<P ALIGN="JUSTIFY">Сигнал может игнорироваться, могут быть предприняты действия, предусмотренные по 
умолчанию, или процесс может взять на себя функцию обработки сигнала. Если процесс не остановился, 
существует способ заставить его выполнить это требование, послав команду:</P>

<B><P ALIGN="JUSTIFY">kill –9 pid</P>
</B><P ALIGN="JUSTIFY">Иногда и это может не помочь, например, в случае процессов зомби (процесса нет а 
запись о нем имеется), операции в NFS или с ленточным ЗУ.</P>
<P ALIGN="JUSTIFY">Атрибуты пользователя в файле <B>/etc/passwd</B> (одна строка – одна запись):</P>
<B><P ALIGN="JUSTIFY">имя:passwd-encod:UID:GID:комментарии:home-dir:shell</P>

<P ALIGN="JUSTIFY">имя&#9;</B>уникальное регистрационное имя пользователя (вводится при login)</P>
<B><P ALIGN="JUSTIFY">passwd-encod&#9;</B>закодированный пароль пользователя. Часто пароль хранится в 
отдельном файле, а здесь вместо него проставляется символ<B> х</B>. Если в этом поле стоит символ *, то 
данный пользователь в систему войти не может (используется для псевдопользователей)</P>

<B><P ALIGN="JUSTIFY">UID&#9;</B>Идентификатор пользователя, который наследуется порожденными им 
процессами. ROOT имеет UID=0.</P>
<B><P ALIGN="JUSTIFY">GID&#9;</B>Идентификатор первичной группы пользователя, который соответствует 
идентификатору в файле<B> /etc/group, </B>где содержится список имен пользователей-членов группы.</P>
<B><P ALIGN="JUSTIFY">Комментарии&#9;</B>Обычно здесь записывается истинное имя пользователя, здесь может 
быть записана дополнительная информация, например, телефон или e-mail пользователя, считываемые 
программой <B>finger</B>.</P>
<B><P ALIGN="JUSTIFY">home-dir&#9;</B>Базовый каталог пользователя, где он оказывается после входа в 
систему.</P>
<B><P ALIGN="JUSTIFY">Shell&#9;</B>Название программы, используемой системой в качестве командного 
интерпретатора (например,<B> /bin/sh). </B>Разные интерпретаторы используют разные скрипты инициализации 
<B>(.<I>profole, .login</B></I> и т.д.).</P>


<P ALIGN="JUSTIFY">В первой строке скрипта помещается строка #! /bin/sh, указывающая на тип и размещения интерпретатора. Поскольку скрипт исполняется интерпретатором, работает он медленно. Значение PID сохраняется в переменной <B>$$</B>, что можно использовать при формировании имен временных файлов, гарантируя их уникальность. Переменные <B>$1, $2</B> и т.д. несут в себе значения параметров, переданных скрипту. Число таких параметров записывается в переменной <B>$#</B>. Результат работы скрипта заносится в переменную <B>$?</B>. Ненулевое значение <B>$? </B>свидетельствует об ошибке. В переменной $! Хранится PID последнего процесса, запущенного в фоновом режиме. Переменная $* хранит в себе все переменные, переданные скрипту в виде единой строки вида: “$1 $2 $3 …”. Другое представление переданных параметров предлагает переменная $@= “$1” “$2” “$3” …</P>
<B><P ALIGN="CENTER">Таблица 2.</B>  Перенаправление потоков ввода/вывода</P>

<CENTER><TABLE BORDER=10 CELLSPACING=1 CELLPADDING=3 WIDTH=756 bgcolor="ghostwhite">
<TR><TD WIDTH="17%" VALIGN="TOP" bgcolor="gainsboro"><P ALIGN="CENTER">Обозначение</TD>
<TD WIDTH="83%" VALIGN="TOP" bgcolor="gainsboro"><P ALIGN="CENTER">Выполняемая операция</TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><B><P ALIGN="CENTER">&gt;<I>файл</B></I></TD>
<TD WIDTH="83%" VALIGN="TOP"><P ALIGN="JUSTIFY">Стандартный вывод перенаправляется в <I>файл</I></TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><B><P ALIGN="CENTER">&gt;&gt;<I>файл</B></I></TD>
<TD WIDTH="83%" VALIGN="TOP"><P ALIGN="JUSTIFY">Данные из стандартного вывода добавляются в <I>файл</I></TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><B><P ALIGN="CENTER">&lt;<I>файл</B></I></TD>
<TD WIDTH="83%" VALIGN="TOP"><P ALIGN="JUSTIFY">Стандартный ввод перенаправляется в <I>файл</I></TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><B><P ALIGN="CENTER">p1|p2</B></TD>
<TD WIDTH="83%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Вывод программы <I>p1</I> направляется на вход программы <I>p2</I></TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><B><P ALIGN="CENTER">n&gt;<I>файл</B></I></TD>
<TD WIDTH="83%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Перенаправление вывода из файла с идентификатором <I>n</I> в <I>файл</I></TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><B><P ALIGN="CENTER">n&gt;&gt;<I>файл</B></I></TD>
<TD WIDTH="83%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Тоже, что и в предыдущей строке, но данные добавляются к содержимому <I>файла</I></TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><B><P ALIGN="CENTER">n&gt;&amp;m</B></TD>
<TD WIDTH="83%" VALIGN="TOP"><P ALIGN="JUSTIFY">Объединение потоков с идентификаторами <I>n</I> и <I>m</I></TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><B><P ALIGN="CENTER">&lt;&lt;str</B></TD>
<TD WIDTH="83%" VALIGN="TOP">
<P ALIGN="JUSTIFY">“Ввод здесь” – используется стандартный ввод до подстроки str. При этом осуществляется 
подстановка метасимволов интерпретатора</TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><B><P ALIGN="CENTER">&lt;&lt;\str</B></TD>
<TD WIDTH="83%" VALIGN="TOP">
<P ALIGN="JUSTIFY">То же, что и в предшествующей строке, но без подстановки.</TD>
</TR>
</TABLE></CENTER>

<P ALIGN="JUSTIFY">Символ | иногда называется конвейером. Например, команда:</P>
<B><P ALIGN="JUSTIFY">ps – ef | grep proс</P>
</B><P ALIGN="JUSTIFY">осуществляет вывод данных о конкретном процессе <I>proс</I>. Несколько более 
корректна команда:</P>
<B><P ALIGN="JUSTIFY">ps – ef | grep proс grep –v grep</P>
</B><P ALIGN="JUSTIFY">так как в потоке, формируемом командой <B><I>ps</B></I>, присутствуют две строки, 
содержащие <I>proс</I> - строка процесса <I>proс </I>и строка процесса<I> grep</I> с параметром 
<I>proс.</P>
</I><P ALIGN="JUSTIFY">Для запуска выполнения команды в фоновом режиме достаточно завершить ее символов 
&amp;.</P>
<P ALIGN="JUSTIFY">Виртуальная память процесса состоит из сегментов памяти. Размер, содержимое и 
размещение сегментов определяется самой программой (например, применением библиотек). Исполняемые файлы 
могут иметь формат <B>COFF</B> (Common Object File Format) и <B>ELF</B> (Executable and Linking Format).</P>
<P ALIGN="JUSTIFY">Функция <B>main()</B> является первой, определенной пользователем. Именное ей будет 
передано управление после формирования соответствующего окружения запускаемой программы. Функция main 
определяется следующим образом.</P>

<B><P ALIGN="JUSTIFY">main(int argc, char *argv[], char *envp[]);</P>
</B><P ALIGN="JUSTIFY">Аргумент<B> argc </B>определяет число параметров, переданных программе. Указатели на эти параметры передаются с помощью массива argv[], так через argv[0] передается имя программы, argv[1] – несет в себе первый параметр и т.д. до argv[argc-1]. Массив envp[] несет в себе список указателей на переменные окружения, передаваемые программе. Переменные представляют собой строки имя=значение_переменной.</P>
<P ALIGN="JUSTIFY">В среде UNIX существует два базовых интерфейса для файлового ввода/вывода.</P>

<OL><LI>Интерфейс системных вызовов, непосредственно взаимодействующих с ядром ОС.</LI>
<LI>Стандартная библиотека ввода-вывода.</LI></OL>

<P ALIGN="JUSTIFY">С файлом ассоциируется дескриптор, который в свою очередь связан с файловым указателем смещения, начиная с которого будет произведена последующая операция чтения/записи. Каждая операция чтения или записи увеличивает этот указатель на число переданных байтов. При открытии файла указатель принимает значение нуль.</P>

<B><FONT SIZE=4><P ALIGN="JUSTIFY">Процессы</P></FONT></B>

<P ALIGN="JUSTIFY">Процесс характеризуется набором атрибутов и идентификаторов. Важнейшим из них является идентификатор процесса PID и идентификатор родительского процесса PPID. PID является именем процесса в ОС. Существует еще 4 идентификатора, которые определяют доступ к системным ресурсам.</P>

<OL><LI>Идентификатор пользователя – UID.</LI>
<LI>Эффективный идентификатор пользователя – ЕUID</LI>
<LI>Идентификатор группы GID</LI>
<LI>Эффективный идентификатор группы ЕGID.</LI></OL>

<B><I><P ALIGN="JUSTIFY">Процессы с идентификаторами SUID и SGID ни при каких обстоятельствах не должны 
порождать других процессов</B></I>. </P>

<P ALIGN="JUSTIFY">Процесс при реализации использует разные системные ресурсы – память, процессор, 
возможности файловой системы и ввод/вывод. ОС создает иллюзию одновременного исполнения нескольких 
процессов (предполагается, что имеется только один процессор), распределяя ресурсы между ними и 
препятствуя злоупотреблениям.</P>

<P ALIGN="JUSTIFY">Выполнение процесса может происходить в двух режимах – в режиме ядра 
(<B>kernel mode</B>) и в режиме пользователя (<B>user mode</B>). В режиме пользователя процесс исполняет 
команды прикладной программы, доступные на непривилегированном уровне. Для получения каких-либо услуг 
ядра процесс делает системный вызов. При этом могут исполняться инструкции ядра, но от имени процесса, 
реализующего системный вызов. Выполнение процесса переходит в режим ядра, что защищает адресное 
пространство ядра. Следует иметь в виду, что некоторые инструкции, например, изменение содержимого 
регистров управления памятью, возможно только в режиме ядра.</P>

<P ALIGN="JUSTIFY">По этой причине образ процесса состоит из двух частей: данных режима ядра и режима 
пользователя. Каждый процесс представляется в системе двумя основными структурами данных – <B>proc</B> 
и <B>user, </B>описанными в файлах<B> &lt;sys/proc.h&gt; </B>и<B> &lt;say/user.h&gt;, </B>соответственно. 
Структура proc является записью системной таблицы процессов, которая всегда находится в оперативной 
памяти. Запись этой таблицы для активного в данный момент процесса адресуется системной переменной 
<B>curproc</B>. Каждый раз при переключении контекста, когда ресурсы процессора передаются другому 
процессу, соответственно изменяется содержимое переменной <B>curproc, </B>которая теперь будет указывать 
на <B>proc</B> активного процесса.</P>

<P ALIGN="JUSTIFY">Структура user, называемая также <I>u-area</I> или <I>u block</I>, содержит данные о 
процессе, которые нужны ядру при выполнении процесса. В отличие от структуры <B>proc,</B> адресуемой с 
помощью указателя <B>curproc,</B> данные user размещаются в определенном месте виртуальной памяти ядра и 
адресуются через переменную <B>u</B>. u area также содержит стек фиксированного размера – системный стек 
или стек ядра (kernel stack). При выполнении процесса в режиме ядра операционная система использует стек, 
а не стек процесса.</P>

<P ALIGN="JUSTIFY">Современные процессоры поддерживают разбивку адресного пространства на области 
переменного размера – <I>сегменты</I>, и области фиксированного объема – <I>страницы</I>.</P>

<P ALIGN="JUSTIFY">Процессоры Intel позволяют разделить память на несколько логических сегментов. 
Виртуальный адрес при этом состоит из двух частей – селектора сегмента и смещения в пределах сегмента. 
Поле селектора INDEX указывает на дескриптор сегмента, где записано его положение, размер и права доступа 
RPL (Descriptor Privilege Level).</P>

<P ALIGN="JUSTIFY">При запуске программы командный интерпретатор порождает процесс, который наследует все 
4 идентификатора и имеет те же права, что и shell.Так как в сеансе пользователя прародителем всех 
процессов является login shell, то их идентификаторы будут идентичны. При запуске программы сначала 
порождается новый процесс, а затем загружается программа.</P>

<P ALIGN="JUSTIFY">Процесс порождается с помощью системного вызова <B><I>fork</B></I>:</P>
<P ALIGN="JUSTIFY">#include &lt;sys/types.h&gt;<BR>
#include &lt;unistd.h&gt;<BR>
pid_t fork(void);</P>

<P ALIGN="JUSTIFY">Порожденный процесс (дочерний) является точной копией родительского процесса. 
Дочерний процесс наследует следующие атрибуты:</P>

<UL><LI>идентификатор пользователя и группы</LI>
<LI>все указатели и дескрипторы файлов</LI>
<LI>диспозицию сигналов и их обработчики</LI>
<LI>текущий и корневой каталог</LI>
<LI>переменные окружения</LI>
<LI>маску файлов</LI>
<LI>ограничения, налагаемые на процесс</LI>
<LI>управляющий терминал</LI></UL>

<P ALIGN="JUSTIFY">Конфигурация виртуальной памяти также сохраняется (те же сегменты программ, данных, 
стека и пр.). После завершения вызова fork оба процесса будут выполнять одну и ту же инструкцию. 
Отличаются эти процессы PID, PPID (идентификатор родительского процесса), дочерний процесс не имеет 
сигналов, ждущих доставки, отличаются и код, возвращаемый системным вызовом fork (родителю возвращается 
PID дочернего процесса, а дочернему - 0). Если код =0, то возврат осуществляется только в родительский 
процесс.</P>

<P ALIGN="JUSTIFY">Для загрузки исполняемого файла используется вызов <B><I>exec </B></I>(аргумент – 
запускаемая программа). При этом существующий процесс замещается новым, соответствующим исполняемому 
файлу.</P>

<UL><LI>идентификаторы PID и PPID</LI>
<LI>все указатели и дескрипторы файлов, для которых не установлен флаг FD_CLOEXEC</LI>
<LI>идентификаторы пользователя и группы</LI>
<LI>текущий и корневой каталог</LI>
<LI>переменные окружения</LI>
<LI>маску файлов</LI>
<LI>ограничения, налагаемые на процесс</LI>
<LI>управляющий терминал</LI></UL>

<P ALIGN="JUSTIFY">Процессы могут уведомлять друг друга о произошедших событиях с помощью сигналов, 
каждый из которых имеет символьное имя и номер. Сигнал может инициировать попытка деления на 0 или 
обращение по недопустимому адресу.</P>

<P ALIGN="JUSTIFY">ОС UNIX создает иллюзию одновременного исполнения процессов, стараясь эффективно 
распределять между ними имеющиеся ресурсы. Выполнение процесса возможно в режиме ядра (kernel mode) и в 
режиме задачи (user mode). В последнем случае процесс реализует инструкции прикладной программы, 
допустимые на непривилегированном уровне защиты процессора. При этом системные структуры данных 
недоступны. Для получения таких данных процесс делает системный вызов (на время происходит переход 
процесса в режим ядра).</P>

<P ALIGN="JUSTIFY">Каждый процесс представляется в системе двумя основными структурами данных – 
<B>proc</B> и <B>user</B>, описанными в файлах &lt;<B>sys/proc.h</B>&gt; и &lt;<B>sys/user.</B>h&gt;. 
Структура proc представляет собой системную таблицу процессов, которая находится в оперативной памяти 
резидентно. Текущий процесс адресуется системной переменной <B><I>curproc</B></I>. Структура <B>user</B> 
размещается в виртуальной памяти. Область <B>user</B>  содержит также системный стек и стек ядра.</P>

<P ALIGN="JUSTIFY">Распределение оперативной памяти всегда бывает динамическим. Процессы выполняются в 
своем виртуальном адресном пространстве. Виртуальные адреса преобразуются в физические на аппаратном 
уровне при активном участии ОС. Объем виртуальной памяти может значительно превышать объем физической. 
Процессоры обычно поддерживают разделение адресного пространства области переменного размера – сегменты и 
фиксированного размера - страницы. Для каждой страницы может быть задано собственная схема преобразования 
виртуальных адресов в физические. Intel поддерживает работу с сегментами (сегментные регистры), где 
задается селектор сегмента (дескриптор) и смещение в пределах сегмента.</P>

<P ALIGN="JUSTIFY">Распределение ресурсов процессора осуществляется планировщиком, который выделяет 
кванты времени каждому из активных процессов. Здесь приложения делятся на три класса:</P>

<OL>
<LI>Интерактивные</LI>
<LI>Фоновые</LI>
<LI>Реального времени</LI></OL>

<P ALIGN="JUSTIFY">Каждый процесс в UNIX имеет свой контекст (контекст сохраняется при прерывании 
процесса). Контекст определяется следующими составляющими:</P>

<UL><LI>Адресное пространство процесса в режиме user</LI>
<LI>Управляющая информация (proc и user).</LI>
<LI>Окружение процесса (в виде пар переменная=значение).</LI>
<LI>Аппаратный контекст (регистры процессора)</LI></UL>

<P ALIGN="JUSTIFY">Работа планировщика UNIX основана на использовании приоритетов процессов. Если процесс 
имеет наивысший приоритет и готов к работе, планировщик прервет работу текущего процесса, если у него 
более низкий приоритет, даже при условии, что он не выбрал до конца свой квант времени. Работа программы 
ядра обычно не прерывается. Это касается и процессов user, если они в данный момент осуществляют 
системный вызов.</P>

<P ALIGN="JUSTIFY">Каждый процесс имеет два атрибута приоритета – <B><I>текущий</B></I> и 
<B><I>относительный (nice)</B></I>. Первый служит для реализации планирования, второй присваивается при 
порождении процесса и воздействует на значение текущего приоритета. Текущий приоритет может 
характеризоваться кодами 0 (низший) – 127 (высший). Для режима user используются коды приоритета 0-65, а 
для ядра – 66-94 (системный диапазон).</P>

<P ALIGN="JUSTIFY">Процессы с кодами 96-127 имеют фиксированный приоритет, который не может изменить ОС 
(обычно служат для процессов реального времени). </P>

<P ALIGN="JUSTIFY">Процессу, ожидающему освобождения какого-то ресурса, система присваивает значение кода 
приоритета сна, выбираемое из диапазона системных приоритетов (в версии BSD большему коду соответствует 
меньший приоритет). Процессы типа “ожидание ввода с клавиатуры” имеют высокий приоритет сна и им сразу 
предоставляется ресурс процессора. Фоновые же процессы, забирающие много времени ЦПУ, получают 
относительно низкий приоритет. </P>

<P ALIGN="JUSTIFY">Каждую секунду ядро пересчитывает текущие значения кодов приоритета для процессов, 
ожидающих запуска (коды&lt;65), повышая вероятность получения ими требуемого ресурса. Так 4.3BSD 
использует для расчета приоритета процесса следующую формулу:</P>

<B><P ALIGN="JUSTIFY">p_cpu = p_cpu*(2*load)/(2*load+1), </B>где load – среднее число процессов в очереди 
за последнюю секунду. В результате после долгого ожидания даже низкоприоритетный процесс имеет 
определенный шанс получить требуемый ресурс.</P>

<P ALIGN="JUSTIFY">Ядро генерирует и посылает процессу сигнал в ответ на определенные события, вызванные 
самим процессом, другим процессом, прерыванием (например, терминальным) или внешним событием. Это могут 
быть Alarm, нарушение по выделенным квотам, особые ситуации, например деление на нуль и т.д. Некоторые 
сигналы можно заблокировать, отложить их обработку, или проигнорировать, для других (например, SIGKILL и 
SIGSTOP) это невозможно.</P>

<P ALIGN="JUSTIFY">Взаимное влияние процессов в UNIX минимизировано (многозадачность!), но система была 
бы неэффективной, если бы она не позволяла процессам обмениваться данными и сигналами (IPC – Inter 
Process Communications). Для реализации этой задачи в UNIX предусмотрены:</P>

<UL><LI>каналы</LI>
<LI>сигналы</LI>
<LI>FIFO (First-In-First-Out - именованные каналы)</LI>
<LI>очереди сообщений</LI>
<LI>семафоры</LI>
<LI>совместно используемые области памяти</LI>
<LI>сокеты</LI>></UL>

<P ALIGN="JUSTIFY">Для создания канала используется системный вызов  <B><I>pipe</B></I> int pipe(int 
*filedes); который возвращает два дескриптора файла filedes[0] – для записи в канал и filedes[1] для 
чтения из канала. Когда один процесс записывает данные в filedes[0], другой получает их из filedes[1]. 
Здесь уместен вопрос, как этот другой процесс узнает дескриптор filedes[1]?</P>

<P ALIGN="JUSTIFY">Нужно вспомнить, что дочерний процесс наследует все дескрипторы файлов родительского 
процесса. Таким образом, к дескрипторам имеет доступ процесс, сформировавший канал, и все его дочерние 
процессы, что позволяет работать каналам только между родственными процессами. Для независимых процессов 
такой метод обмена недоступен. Канальный обмен может быть запущен и с консоли. Например:</P>

<B><P ALIGN="JUSTIFY">cat file.txt | wc</P>

</B><P ALIGN="JUSTIFY">Здесь символ | олицетворяет создание канала между выводом из файла <B>file.txt</B> 
и программой <B>wc</B>, подсчитывающей число символов в словах. Процессы эти не являются независимыми, 
так как оба порождены процессом <B>shell</B>.</P>

<P ALIGN="JUSTIFY">Метод <B>FIFO</B> (в BSD не реализован) сходен с канальным обменом, так как также 
организует лишь однонаправленный обмен. Такие каналы имеют имена, что позволяет их применять при обмене 
между независимыми процессами. <B>FIFO</B> – это отдельный тип файла в файловой системе UNIX. Для 
формирования FIFO используется системный вызов <B>mknod</B>.</P>

<B><P ALIGN="JUSTIFY">int mknod(char *pathname, int mode, int dev);</P>
</B><P ALIGN="JUSTIFY">где <B>pathname</B> – имя файла (<B>FIFO</B>),<BR>
<B>mode</B> – флаги владения и прав доступа,<BR>
<B>dev</B> – при создании <B>FIFO </B>игнорируется.</P>

<P ALIGN="JUSTIFY">Допускается создание <B>FIFO</B> и из командной строки: <B>mknod name p</B>.<BR>
<B>FIFO </B>также как и обычные канала работают с соблюдением следующих правил.</P>

<UL><LI>Если из канала берется меньше байтов, чем там содержится, остальные остаются там 
для последующего чтения.</LI>
<LI>При попытке прочесть больше байт, чем имеется в канале, читающий процесс должен 
соответствующим образом обработать возникшую ситуацию.</LI>
<LI>Если в канале ничего нет и ни один процесс не открыл его на запись, при чтении будет получено нуль 
байтов. Если один или более процессов открыло канал на запись, вызов read будет заблокирован до появления 
данных.</LI>
<LI>В случае записи в канал несколькими процессами, эти данные не перемешиваются.</LI>
<LI>При попытке записать большее число байтов, чем это позволено каналом или FIFO, вызов <B>write</B> 
блокируется до освобождения нужного места. Если процесс предпринимает попытку записи  в канал, не 
открытый ни одним из процессов для чтения, процессу посылается сигнал SIGPIPE, а вызов write присылает 
0 с кодом ошибки errno=EPIPE.</LI></UL>

<B><FONT SIZE=4><P ALIGN="JUSTIFY">Сообщения</P></B></FONT>

<P ALIGN="JUSTIFY">Очереди сообщения являются составной частью UNIX System V. Процесс, заносящий 
сообщение в очередь, может не ожидать чтения этого сообщения каким-либо другим процессом. Сообщения 
имеют следующие атрибуты:</P>

<UL><LI>Тип сообщения</LI>
<LI>Длина данных в байтах</LI>
<LI>Данные (если длина ненулевая)</LI></UL>

<P ALIGN="JUSTIFY">Очередь сообщений имеет вид списка в адресном пространстве ядра. Для каждой очереди 
ядро формирует заголовок(msqid_ds), где размещаются данные о правах доступа к очереди (msg_perm), о 
текущем состоянии очереди (msg_cbytes – число байтов msg_qnum – число сообщений в очереди), а также 
указатели на первое и последнее сообщение. Создание новой очереди сообщений осуществляется посредством 
системного вызова msgget:</P>


<P ALIGN="JUSTIFY">#include &lt;sys/types.h&gt;<BR>
#include &lt;sys/ipc.h&gt;<BR>
#include e &lt;sys/ipc.h&gt;<BR>
int msgget( key_t key, int msgflag );</P>

<P ALIGN="JUSTIFY">&#9;Эта функция выдает дескриптор элемента очереди, или –1 - в случае ошибки. Процесс 
может с помощью оператора <B>msgsnd</B> поместить сообщение в очередь, получить сообщение из очереди 
посредством <B>msgrcv </B>и манипулировать сообщениями с помощью<B> msgctl</B>. </P>

<B><FONT SIZE=5><P ALIGN="JUSTIFY">Семафоры</P></FONT></B>

<P ALIGN="JUSTIFY">Для управления доступом нескольких процессов к разделяемым ресурсам 
используются семафоры. Семафоры являются одной из форм IPC (Inter-Process Communication). Для обеспечения 
работы нужно обеспечить выполнение следующих условий:</P>

<UL><LI>Семафор должен быть доступен разным процессам и, по этой причине, находиться в адресной среде 
ядра.</LI>
<LI>Операция проверки и изменения семафора должна быть реализована в режиме ядра.</LI></UL>

<P ALIGN="JUSTIFY">Помимо значения семафора в структуре <B>sem</B> записывается идентификатор процесса, 
вызвавшего последнюю операцию над семафором, число процессов, ожидающих увеличения значения семафора.</P>

<B><FONT SIZE=5><P ALIGN="JUSTIFY">Разделяемая память</P></B></FONT>

<P ALIGN="JUSTIFY">Активное использование каналов, FIFO и очередей сообщений может привести к снижению 
производительности машины. Это сопряжено с тем, что передаваемые данные сначала из буфера передающего 
процесса в буфер ядра, и только затем в буфер принимающего процесса. Техника разделяемой памяти позволяет 
избавиться от этих потерь, предоставив доступ двум или более процессам доступ общей зоне памяти.</P>

<P ALIGN="JUSTIFY">Пока один процесс читает данные из разделяемой памяти, другой не должен туда писать и 
наоборот. Такого рода согласование работы осуществляется посредством семафоров.</P>

<B><FONT  SIZE=4><P ALIGN="JUSTIFY">Файловая система</P></FONT>

</B><P ALIGN="JUSTIFY">В настоящее время UNIX использует виртуальную файловую систему, которая 
допускает работу с несколькими физическими файловыми системами самых разных типов. Система S5FS занимает 
раздел диска и состоит из трех компонентов.</P>

<UL><B><LI>Суперблока</B>, где хранится общая информация о файловой системе, о ее архитектуре, числе 
блоков, и индексных дескрипторов (inode).</LI>
<B><LI>Массива индексных дескрипторов</B> (ilist), где записаны метаданные всех файлов системы. Индексный 
дескриптор содержит статусные данные о файле и информацию о расположении этих данных на диске. Ядро 
обращается к inode по индексу массива ilist. Один inode является корневым, через него происходит доступ к 
структуре каталогов и файлов после монтирования файловой системы.</LI>
<B><LI>Блоки данных</B> файлов и каталогов. Размер блока кратен 512 байтам.</LI></UL>

<P ALIGN="JUSTIFY">Индексный дескриптор (inode) несет в себе информацию о файле, необходимую для 
обработки метаданных файла. Каждый файл ассоциируется с одним inode. При открытии файла ядро записывает 
копию inode в таблицу in-core inode.</P>

<P ALIGN="JUSTIFY">Слабой точкой файловой системы F5FS является суперблок. Он записан на диске в одном 
экземпляре и по этой причине уязвим. Низкая производительность этой файловой системы связана с тем, что 
метаданные файлов размещены в начале диска, а данные на относительном расстоянии от них. Это вызывает 
постоянные перемещения считывающих головок, снижая быстродействие системы.</P>

<P ALIGN="JUSTIFY">Имена файлов хранятся в специальных файлах, называемых каталогами. По этой причине 
любой реальный файл данных может иметь любое число имен. Каталог файловой системы представляет собой 
таблицу, каждый элемент которой имеет длину 16 байтов: 2 байта номер индексного дескриптора, 14 – его 
имя. Число inode не может превышать 65535. Имя файла в этой системе (S5FS) не должно превышать 14 
символов.</P>имеет имя “..”.</P>

<P ALIGN="JUSTIFY">При удалении имени файла из каталога номер соответствующего inode устанавливается 
равным 0. Ядро не удаляет свободные элементы, по этой причине размер каталога при удалении файлов не 
уменьшается.</P>

<P ALIGN="JUSTIFY">Новая файловая система FFS (Berkeley Fast File System) использует те же структуры 
длинные имена файлов (до 255 символов). Записи каталога имеют следующую структуру:</P>

<P ALIGN="JUSTIFY">d_namlen - Длина имени файла<BR>
d_name[] - Имя файла</P>

<P ALIGN="JUSTIFY">Имя файла имеет переменную длину, дополняемую нулями до 4-байтовой границы. Метаданные 
активных файлов, на которые ссылаются один или более процессов, представлены в памяти в виде in-core 
inode. В виртуальной файловой системе в качестве in-core inode выступает <B>vnode</B>. Структура vnode 
одинакова для всех файлов и не зависит от типа файловой системы. vnode содержит данные, необходимые для 
работы виртуальной файловой системы, а также характеристики файла, такие как его тип.</P>
<BR>
<P>Получение описания инструкций (Help): man &lt;имя объекта&gt;</P>
<P>Уход из UNIX Ctrl-d или logout.</P>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=2 WIDTH=800>
<TR><TD WIDTH="25%" valign="top"><b><p>passwd</b></td>
<td width="75%" valign="top"><p>Смена пароля пользователя</td>
</tr>
<tr><td width="25%" valign="top"><p><b>Вызов редактора</b></td>
<td width="75%" valign="top"><p>ed - строчный редактор; sed - потоковый редактор</font></td>
</tr>
<tr><td width="25%" valign="top"><b><p>pwd</b></td>
<td width="75%" valign="top"><p>Выдача полного имени текущего каталога</font></td>
</tr>
<tr><td width="25%" valign="top"><b><p>clear</b></td>
<td width="75%" valign="top"><p>Очистка экрана терминала.  </td>
</tr>
</table>

<b><p>ls [-флаги...] имя... Распечатка каталога</p>
</b><p>Флаги:</p>
<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="13%" valign="top"><p>-a</td>
<td width="87%" valign="top"><p>печатает все имена файлов в каталоге;</td>
</tr>
<tr><td width="13%" valign="top"><p>-c</td>
<td width="87%" valign="top"><p>сортирует список файлов по времени последней модификации;</td>
</tr>
<tr><td width="13%" valign="top"><p>-d</td>
<td width="87%" valign="top"><p>печатает информацию только о каталогах (эквивалентно -l);</td>
</tr>
<tr><td width="13%" valign="top"><p>-f</td>
<td width="87%" valign="top"><p>для каждого подкаталога выводит его содержимое, этот флаг выключает все другие флаги;</td>
</tr>
<tr><td width="13%" valign="top"><p>-g</td>
<td width="87%" valign="top"><p>вместо идентификатора владельца печатается идентификатор группы;</td>
</tr>
<tr><td width="13%" valign="top"><p>-l</td>
<td width="87%" valign="top"><p>печатает полную информацию о файлах;</td>
</tr>
<tr><td width="13%" valign="top"><p>-r</td>
<td width="87%" valign="top"><p>сортирует список в обратном порядке;</td>
</tr>
<tr><td width="13%" valign="top"><p>-s</td>
<td width="87%" valign="top"><p>выводит размер файлов в блоках;</td>
</tr>
<tr><td width="13%" valign="top"><p>-t</td>
<td width="87%" valign="top"><p>сортировка по времени;</td>
</tr>
<tr><td width="13%" valign="top"><p>-u</td>
<td width="87%" valign="top"><p>сортирует список файлов по времени последнего доступа.</td>
</tr>
<tr><td width="13%" valign="top"><p>lc</td>
<td width="87%" valign="top"><p>Вывод содержимого каталога по столбцам (аналогична ls, но присутствует не во всех системах);</td>
</tr>
</table>

<p>&nbsp;</p>
<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="67%" valign="top"><p>Образование нового каталога</td>
<td width="33%" valign="top"><b><p>mkdir</b></td>
</tr>
</table>

<p>Например: <b>mkdir A B</b> (образует 2 каталога)</p>
<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="67%" valign="top"><p>Переход из каталога в каталог</td>
<td width="33%" valign="top"><p>cd</td>
</tr>
<tr><td width="67%" valign="top"><p>Возвращение в предыдущий каталог</td>
<td width="33%" valign="top"><p>cd ..</td>
</tr>
<tr><td width="67%" valign="top"><p>Переход в параллельный каталог b</td>
<td width="33%" valign="top"><p>cd ../b</td>
</tr>
<tr><td width="67%" valign="top"><p>Возврат в базовый каталог</td>
<td width="33%" valign="top"><p>cd ../../</td>
</tr>
</table>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="67%" valign="top"><p>Удаление каталога</td>
<td width="33%" valign="top"><b><p>rmdir &lt;имя_каталога&gt;</b></td>
</tr>
</table>

<p>Доступ к каталогу. Проверка существования файлов и каталогов, а также установленных для них возможностей.</p>
<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td valign="top"><p align="justify"><img src="image485.gif" tppabs="http://book.itep.ru/10/image485.gif"></P>
<B><P ALIGN="JUSTIFY">test &lt;параметр&gt; &lt;файл&gt;</B></TD>
</TR>
</TABLE>

<P ALIGN="JUSTIFY">Команда test позволяет также сравнивать целые числа (напр., test "$X" -eq "$Y"). &lt;параметр&gt; возвращает значение true, если файл существует и:</P>

<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=2 WIDTH=800>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">-b</TD>
<TD WIDTH="87%" VALIGN="TOP"><P ALIGN="JUSTIFY">является блочным специальным файлом;</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">-c</TD>
<TD WIDTH="87%" VALIGN="TOP"><P ALIGN="JUSTIFY">символьным специальным файлом;</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">-d</TD>
<TD WIDTH="87%" VALIGN="TOP"><P ALIGN="JUSTIFY">каталогом;</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">-f</TD>
<TD WIDTH="87%" VALIGN="TOP"><P ALIGN="JUSTIFY">обычным файлом (не каталогом);</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">-g</TD>
<TD WIDTH="87%" VALIGN="TOP"><P ALIGN="JUSTIFY">установлен бит идентификатора группы;</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">-k</TD>
<TD WIDTH="87%" VALIGN="TOP"><P ALIGN="JUSTIFY">второй промежуточный бит округления;</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">-r</TD>
<TD WIDTH="87%" VALIGN="TOP"><P ALIGN="JUSTIFY">доступен для чтения;</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">-s</TD>
<TD WIDTH="87%" VALIGN="TOP"><P ALIGN="JUSTIFY">имеет ненулевой размер;</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">-t[fds]</TD>
<TD WIDTH="87%" VALIGN="TOP"><P ALIGN="JUSTIFY">открытый файл с дескриптором fsd связан с 
терминалом (по умолчанию fsd=1);</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">-u</TD>
<TD WIDTH="87%" VALIGN="TOP"><P ALIGN="JUSTIFY">установлен бит идентификатора пользователя;</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">-w</TD>
<TD WIDTH="87%" VALIGN="TOP"><P ALIGN="JUSTIFY">доступен для записи;</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">-x</TD>
<TD WIDTH="87%" VALIGN="TOP"><P ALIGN="JUSTIFY">для исполнения.</TD>
</TR>
</TABLE>

<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=2 WIDTH=800>
<TR><TD WIDTH="33%" VALIGN="TOP"><B><P>cat [файл1 файл2 ...]</B></TD>
<TD WIDTH="67%" VALIGN="TOP"><P>Слияние файлов (если указано одно имя команда выводит содержимое на терминал, эквивалентно команде page)</TD>
</TR>
</TABLE>

<P>Копирование файлов (файла в файл или файлов в каталог)</P>
<P>cp файл1 файл2 или cp файл1 файл2 .... файлN каталог.</P>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=2 WIDTH=800>
<TR><TD WIDTH="13%" VALIGN="TOP"><B><P>uucp</B></TD>
<TD WIDTH="87%" VALIGN="TOP"><P>делает то же, что и cp, но между двумя UNIX машинами в сети.</TD>
</TR>
</TABLE>

<P>uucp [флаги] файл1 имя_ЭВМ!файл2</P>
<P ALIGN="JUSTIFY">имя ЭВМ отделяется от имени файла с помощью "!". Перед именем файл2 необходимо указать также имя каталога или поставить "~", если оно неизвестно. </P>

<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=2 WIDTH=709>
<TR><TD WIDTH="18%" VALIGN="TOP"><P ALIGN="JUSTIFY">Например:</TD>
<TD WIDTH="82%" VALIGN="TOP"><P ALIGN="JUSTIFY">/usr/ivanov/news или ~ivanov/news.</TD>
</TR>
</TABLE>

<P>Флаги:</P>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=2 WIDTH=800>
<TR><TD WIDTH="18%" VALIGN="TOP"><P>-m</TD>
<TD WIDTH="82%" VALIGN="TOP"><P>посылает сообщение отправителю о доставке файла1;</TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP"><P>-n</TD>
<TD WIDTH="82%" VALIGN="TOP"><P>посылает аналогичное сообщение получателю.</TD>
</TR>
</TABLE>

<P>Переименование файлов или каталогов</P>
<P>mv файл1 файл2 или mv каталог1 каталог2</P>
<B><P>Печать файлов</P>
</B><P ALIGN="JUSTIFY">Печать содержимого одного или нескольких файлов c автоматическим разбиением на страницы и с заголовком на каждой странице;</P>
<B><P>pr [флаги]...[файл]...</P>
</B><P>Флаги:</P>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=2 WIDTH=709>
<TR><TD WIDTH="17%" VALIGN="TOP"><P>-h</TD>
<TD WIDTH="83%" VALIGN="TOP"><P>задает заголовок;</TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><P>-ln</TD>
<TD WIDTH="83%" VALIGN="TOP"><P>задает длину страницы в n строк (по умолчанию - 60);</TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><P>-m</TD>
<TD WIDTH="83%" VALIGN="TOP"><P>Печатать все файлы одновременно в своих колонках;</TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><P>-n</TD>
<TD WIDTH="83%" VALIGN="TOP"><P>в n колонок;</TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><P>+n</TD>
<TD WIDTH="83%" VALIGN="TOP"><P>начиная со страницы n;</TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><P>-t</TD>
<TD WIDTH="83%" VALIGN="TOP"><P>не печатать 5 строк заголовка и 5 последних строк страницы;</TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><P>-wn</TD>
<TD WIDTH="83%" VALIGN="TOP"><P>задает ширину стр. в n символов (по умолчанию - 72);</TD>
</TR>
</TABLE>

<B><P>&nbsp;</P></B>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=2 WIDTH=709>
<TR><TD WIDTH="28%" VALIGN="TOP"><B><P>more [файл]</B></TD>
<TD WIDTH="72%" VALIGN="TOP"><B><P>Отображает файл поэкранно.</B></TD>
</TR>
</TABLE>

<P>Печать файлов одновременно с выполнением других операций</P>
<B><P>lpr [флаги]...[файл]...</P>
</B><P>Флаги:</P>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=2 WIDTH=709>
<TR><TD WIDTH="23%" VALIGN="TOP"><P>-c</TD>
<TD WIDTH="77%" VALIGN="TOP"><P>cкопировать файл перед печатью;</TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP"><P>-m</TD>
<TD WIDTH="77%" VALIGN="TOP"><P>отправить почтовое сообщение по завершении печати;</TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP"><P>-n</TD>
<TD WIDTH="77%" VALIGN="TOP"><P>не сообщать по почте о завершении печати (по умолчанию);</TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP"><P>-r</TD>
<TD WIDTH="77%" VALIGN="TOP"><P>удалить файл после печати.</TD>
</TR>
</TABLE>

<B><P>lp [флаги] [файл_1, файл_2,....файл_N]</P>
</B><P>Флаги:</P>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=2 WIDTH=709>
<TR><TD WIDTH="23%" VALIGN="TOP"><P>-d</TD>
<TD WIDTH="77%" VALIGN="TOP"><P>задает имя принтера;</TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP"><P>-o</TD>
<TD WIDTH="77%" VALIGN="TOP"><P>служит для задания субпараметров печати;</TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP"><P>-n[число]</TD>
<TD WIDTH="77%" VALIGN="TOP"><P>задает число копий печати;</TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP"><P>-m</TD>
<TD WIDTH="77%" VALIGN="TOP"><P>выводит на терминал сообщение по завершении печати;</TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP"><P>-q[приоритет]</TD>
<TD WIDTH="77%" VALIGN="TOP"><P>определяет уровень приоритета для запросов печати (максимальный - 0, минимальный -39);</TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP"><P>-s</TD>
<TD WIDTH="77%" VALIGN="TOP"><P>блокирует сообщение "request идентификатор";</TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP"><P>-R</TD>
<TD WIDTH="77%" VALIGN="TOP"><P>удаляет напечатанные файлы;</TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP"><P>-L</TD>
<TD WIDTH="77%" VALIGN="TOP"><P>использует подключенный к вашему терминалу локальный принтер;</TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP"><P>lprint</TD>
<TD WIDTH="77%" VALIGN="TOP"><P>эквивалент команды pr -L;</TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP"><P>lpstat</TD>
<TD WIDTH="77%" VALIGN="TOP"><P>выдает сообщение о статусе принтера;</TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP"><P>cancel</TD>
<TD WIDTH="77%" VALIGN="TOP"><P>отменяет запрос вывода на печать.</TD>
</TR>
</TABLE>

<B><P>Сравнение файлов</B> </P>
<P>Сравнение файлов и выдача отчета о различиях;</P>
<B><P>cmp [-l][-s] файл1 файл2</P>
</B><P>Флаги:</P>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=2 WIDTH=709>
<TR><TD WIDTH="23%" VALIGN="TOP"><P>-l</TD>
<TD WIDTH="77%" VALIGN="TOP"><P>выдача полного списка различий;</TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP"><P>-s</TD>
<TD WIDTH="77%" VALIGN="TOP"><P>выдача кода результата; (если равны - 0; неравны - 1; хотя бы один недоступен - 2);</TD>
</TR>
</TABLE>

<P>Удаление файлов</P>
<B><P>rm [флаги] файл</P>
</B><P>Флаги:</P>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=2 WIDTH=709>
<TR><TD WIDTH="8%" VALIGN="TOP"><P>-f</TD>
<TD WIDTH="92%" VALIGN="TOP"><P>если для файла запрещена запись/чтение;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP"><P>-i</TD>
<TD WIDTH="92%" VALIGN="TOP"><P>удаление в интерактивном режиме; ( * означает - все файлы каталога);</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP"><P>-r</TD>
<TD WIDTH="92%" VALIGN="TOP"><P>* удаление всех файлов и подкаталогов;</TD>
</TR>
</TABLE>

<P>Поиск файлов</P>
<B><P>find каталог ... аргументы ...</P>
</B><P ALIGN="JUSTIFY">Просматриваются рекурсивно все подкаталоги для каждого указанного каталога и ищутся файлы отвечающие условиям, заданным в аргументах. Числовые аргументы со знаком "+" означают "больше чем", а числовой аргумент со знаком "-" "меньше чем". Аргументы - это условия поиска; любому аргументу предшествует знак "-", все аргументы считаются соединенными знаком "И". 
-o соединитель ИЛИ, перед каждым символом "ИЛИ" должен ставиться знак "\";</P>
<P>Допускаются аргументы:</P>

<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=2 WIDTH=800>
<TR><TD WIDTH="28%" VALIGN="TOP"><P>-name имя файла</TD>
<TD WIDTH="72%" VALIGN="TOP"><P>имя файла совпадает с заданным;</TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP"><P>-type c</TD>
<TD WIDTH="72%" VALIGN="TOP"><P>тип файла совпадает с с;</TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP"><P>-links n</TD>
<TD WIDTH="72%" VALIGN="TOP"><P>файл имеет n связей;</TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP"><P>-user имя</TD>
<TD WIDTH="72%" VALIGN="TOP"><P>файл принадлежит пользователю с данным именем;</TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP"><P>-group имя</TD>
<TD WIDTH="72%" VALIGN="TOP"><P>файл принадлежит группе с именем;</TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP"><P>-size n</TD>
<TD WIDTH="72%" VALIGN="TOP"><P>длина файла равна n блокам;</TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP"><P>-inum n</TD>
<TD WIDTH="72%" VALIGN="TOP"><P>индекс файла равен n;</TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP"><P>-mtime n</TD>
<TD WIDTH="72%" VALIGN="TOP"><P>последняя модификация файла была n дней назад;</TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP"><P>-exec команда</TD>
<TD WIDTH="72%" VALIGN="TOP"><P>выполняется команда UNIX;</TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP"><P>-ok команда</TD>
<TD WIDTH="72%" VALIGN="TOP"><P>то же, что и -exec, но печатается на терминале;</TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP"><P>-print</TD>
<TD WIDTH="72%" VALIGN="TOP"><P>печатается имя текущего файла;</TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP"><P>-newer файл</TD>
<TD WIDTH="72%" VALIGN="TOP"><P>текущий файл был модифицирован позже заданного</TD>
</TR>
</TABLE>

<P>Очистка индексного дескриптора</P>
<B><P>clri файл-система индекс...</P>
</B><P>Удаляет индексный дескриптор для файла, отсутствующего в каталогах.</P>
<P>Библиотекарь</P>
<B><P>ar флаги [имя] библиотека [файл...]</P>
</B><P>Флаги:</P>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=2 WIDTH=800>
<TR><TD WIDTH="8%" VALIGN="TOP"><P>a</TD>
<TD WIDTH="92%" VALIGN="TOP"><P>указывает (совместно с r или m) на то, что файлы следует помещать после заданного файла;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP"><P>b</TD>
<TD WIDTH="92%" VALIGN="TOP"><P>то же, что и a, но файлы размещаются перед заданным файлом;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP"><P>c</TD>
<TD WIDTH="92%" VALIGN="TOP"><P>создание библиотечного файла;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP"><P>d</TD>
<TD WIDTH="92%" VALIGN="TOP"><P>удалить файлы из библиотеки;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP"><P>l</TD>
<TD WIDTH="92%" VALIGN="TOP"><P>поместить временные файлы библиотекаря в текущем каталоге;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP"><P>m</TD>
<TD WIDTH="92%" VALIGN="TOP"><P>переместить файлы в конец библиотеки или вслед за указанным файлом;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP"><P>p</TD>
<TD WIDTH="92%" VALIGN="TOP"><P>напечатать содержимое заданных файлов;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP"><P>q</TD>
<TD WIDTH="92%" VALIGN="TOP"><P>добавить файлы в конец библиотеки;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP"><P>r</TD>
<TD WIDTH="92%" VALIGN="TOP"><P>заменить файлы в библиотеке на новые. Если файлов нет, они просто добавляются;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP"><P>t</TD>
<TD WIDTH="92%" VALIGN="TOP"><P>перечислить файлы, входящие в библиотеку;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP"><P>u</TD>
<TD WIDTH="92%" VALIGN="TOP"><P>совместно с r указывает, что будет заменяться только те файлы библиотеки, которые были модифицированы раньше заданных файлов.</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP"><P>v</TD>
<TD WIDTH="92%" VALIGN="TOP"><P>печать дополнительной информации (вид действия, имя файла) применяется совместно с d, m, r, x;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP"><P>x</TD>
<TD WIDTH="92%" VALIGN="TOP"><P>скопировать файлы в текущий каталог;</TD>
</TR>
</TABLE>

<P>Построение таблицы с содержанием библиотеки</P>
<B><P>ranlib [библиотека]</P>
</B><P>Служит для подготовки работы редактора связей.</P>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=2 WIDTH=710>
<TR><TD WIDTH="50%" VALIGN="TOP"><P>Установка кода защиты файла</TD>
<TD WIDTH="50%" VALIGN="TOP"><P>chmod код</TD>
</TR>
</TABLE>

<P><B> chmod код_защиты файл ...</B> </P>
<P>4000 разрешение смены идентификатора пользователя;<BR>
2000 разрешение смены идентификатора группы;<BR>
1000 сохранение образа файла после отсоединения всех процессов;<BR>
0400 разрешение чтения владельцу файла;<BR>
0200 разрешение записи владельцу файла;<BR>
0100 разрешение записи, чтения и выполнения владельцу;<BR>
0070 разрешение записи, чтения и выполнения группе;<BR>
0007 разрешение чтения, записи, исполнения всем.</P>
<P>Символьная форма позволяет установить биты кода защиты индивидуально и имеет вид:</P>
<B><P>[ugoa][+-=][rwxstugo],</B> где</P>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=2 WIDTH=709>
<TR><TD WIDTH="11%" VALIGN="TOP"><P>u</TD>
<TD WIDTH="89%" VALIGN="TOP"><P>владелец,</TD>
</TR>
<TR><TD WIDTH="11%" VALIGN="TOP"><P>g</TD>
<TD WIDTH="89%" VALIGN="TOP"><P>группа,</TD>
</TR>
<TR><TD WIDTH="11%" VALIGN="TOP"><P>o</TD>
<TD WIDTH="89%" VALIGN="TOP"><P>прочие,</TD>
</TR>
<TR><TD WIDTH="11%" VALIGN="TOP"><P>a</TD>
<TD WIDTH="89%" VALIGN="TOP"><P>все категории пользователей (по умолчанию),</TD>
</TR>
<TR><TD WIDTH="11%" VALIGN="TOP"><P>+</TD>
<TD WIDTH="89%" VALIGN="TOP"><P>разрешить доступ,</TD>
</TR>
<TR><TD WIDTH="11%" VALIGN="TOP"><P>-</TD>
<TD WIDTH="89%" VALIGN="TOP"><P>запретить доступ,</TD>
</TR>
<TR><TD WIDTH="11%" VALIGN="TOP"><P>r</TD>
<TD WIDTH="89%" VALIGN="TOP"><P>чтение,</TD>
</TR>
<TR><TD WIDTH="11%" VALIGN="TOP"><P>w</TD>
<TD WIDTH="89%" VALIGN="TOP"><P>запись,</TD>
</TR>
<TR><TD WIDTH="11%" VALIGN="TOP"><P>x</TD>
<TD WIDTH="89%" VALIGN="TOP"><P>исполнение,</TD>
</TR>
<TR><TD WIDTH="11%" VALIGN="TOP"><P>s</TD>
<TD WIDTH="89%" VALIGN="TOP"><P>смена идентификатора пользователя или группы,</TD>
</TR>
<TR><TD WIDTH="11%" VALIGN="TOP"><P>t</TD>
<TD WIDTH="89%" VALIGN="TOP"><P>сохранение образа файла в области выгрузки,</TD>
</TR>
<TR><TD WIDTH="11%" VALIGN="TOP"><P>ugo</TD>
<TD WIDTH="89%" VALIGN="TOP"><P>оставить текущее значение бита доступа.</TD>
</TR>
</TABLE>

<P>Проверка корректности каталогов</P>
<B><P>dcheck [индексы][файловая система]</P>
</B><P ALIGN="JUSTIFY">Сравнивает счетчик числа связей в индексном дескрипторе с числом записей в каталогах, ссылающихся на данный дескриптор. Индексы генерируются командой icheck. Проверка распределения памяти в файловой системе </P>
<B><P>icheck [-s][-b блок...][файловая система]</P>
</B><P ALIGN="JUSTIFY">Исследуется файловая система, проверяется правильность списков свободных и используемых блоков, выводит общее число файлов, каталогов, число используемых блоков, число свободных блоков и т.д.</P>
<P>Флаги:</P>
<P>-b выдача диагностических сообщений для заданных</P>
<P>блоков.</P>
<P>-s создание списка свободных блоков;</P>
<P>Генерация имен файлов по заданным индексам</P>
<B><P>nchek [-i индексы] [-a][-s][файловая система]</P>

</B><P ALIGN="JUSTIFY">Генерирует полные имена файлов для заданного списка индексов файловой системы, осуществляет поиск имен поврежденных файлов.</P>
<P>Флаги:</P>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=2 WIDTH=709>
<TR><TD WIDTH="11%" VALIGN="TOP"><P>-a</TD>
<TD WIDTH="89%" VALIGN="TOP"><P>печатает тот же список, что и для флага -i и дополнительно все файлы, имена которых начинаются с "." и "..".</TD>
</TR>
<TR><TD WIDTH="11%" VALIGN="TOP"><P>-i</TD>
<TD WIDTH="89%" VALIGN="TOP"><P>печатает полный список файлов для индексов, перечисленных после данного флага.</TD>
</TR>
<TR><TD WIDTH="11%" VALIGN="TOP"><P>-s</TD>
<TD WIDTH="89%" VALIGN="TOP"><P>печатаются только специальные файлы и файлы с установленным режимом смены идентификатора пользователя.</TD>
</TR>
</TABLE>

<P>Создание файловой системы</P>
<B><P>/etc/mkfs [файловая система][размер]</P>
</B><P ALIGN="JUSTIFY">Создает новую файловую систему на диске или части диска согласно числу блоков, заданному аргументом размер. Такая система может быть присоединена к основной файловой системе с помощью команды mount.</P>
<P>Создание специальных файлов</P>
<B><P>/etc/mknod имя [c][b] тип устройство</P>

</B><P ALIGN="JUSTIFY">Создание специальных файлов, располагающихся в каталоге /dev, где описываются характеристики драйверов устройств и файловых систем. Аргументы тип и устройство относятся к драйверу и к специальному входу в драйвер.</P>

<P>Монтирование файловой системы</P>
<B><P>/etc/mount файловая-система [-r] имя файла</P>
</B><P>Демонтирование файловой системы</P>
<B><P>/etc/umount файловая-система</P>
</B><P>Временная смена идентификатора пользователя</P>
<B><P>su [идентификатор]</P>
</B><P ALIGN="JUSTIFY">Изменяет идентификатор пользователя, и выполняет операции, которые возможно было бы нельзя выполнить с другим идентификатором из-за отсутствия права доступа. Для возврата к исходной среде следует нажать ctrl-d.</P>

<B><P>Модификация суперблока - sync</P>
</B><P ALIGN="JUSTIFY">Освобождаются буферы и модифицируется файловая система на диске. Sync автоматически выполняется через заданный промежуток времени, задаваемый администратором.</P>

<P>Библиотекарь магнитной ленты (или дискеты)</P>
<B><P>tar [флаги][имя]</P>
</B><P ALIGN="JUSTIFY">Сохраняет и восстанавливает файлы и каталоги с использованием магнитной ленты (или дискет).</P>
<P>Флаги:</P>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=2 WIDTH=709>
<TR><TD WIDTH="11%" VALIGN="TOP"><P>c</TD>
<TD WIDTH="89%" VALIGN="TOP"><P>создает новую ленту для записи на нее файлов;</TD>
</TR>
<TR><TD WIDTH="11%" VALIGN="TOP"><P>r</TD>
<TD WIDTH="89%" VALIGN="TOP"><P>заданные файлы записываются в конец ленты;</TD>
</TR>
<TR><TD WIDTH="11%" VALIGN="TOP"><P ALIGN="JUSTIFY">t</TD>
<TD WIDTH="89%" VALIGN="TOP"><P ALIGN="JUSTIFY">печатает список файлов и каталогов, имеющихся на ленте, из числа заданных в команде;</TD>
</TR>
<TR><TD WIDTH="11%" VALIGN="TOP"><P ALIGN="JUSTIFY">x</TD>
<TD WIDTH="89%" VALIGN="TOP"><P ALIGN="JUSTIFY">чтение с ленты заданных файлов или каталогов, если имеется несколько версий, читается последняя;</TD>
</TR>
<TR><TD WIDTH="11%" VALIGN="TOP"><P ALIGN="JUSTIFY">u</TD>
<TD WIDTH="89%" VALIGN="TOP"><P ALIGN="JUSTIFY">заданные файлы добавляются на ленту, если их там нет или если это новые версии. Следующие флаги используются для модификации вышеприведенных функций.</TD>
</TR>
<TR><TD WIDTH="11%" VALIGN="TOP"><P ALIGN="JUSTIFY">b</TD>
<TD WIDTH="89%" VALIGN="TOP"><P ALIGN="JUSTIFY">коэффициент блокирования при чтении и записи, по умолчанию = 1, максимальное значение = 20;</TD>
</TR>
<TR><TD WIDTH="11%" VALIGN="TOP"><P ALIGN="JUSTIFY">f</TD>
<TD WIDTH="89%" VALIGN="TOP"><P ALIGN="JUSTIFY">следующий за f аргумент рассматривается как имя устройства вместо принятого по умолчанию /dev/mt?.</TD>
</TR>
<TR><TD WIDTH="11%" VALIGN="TOP"><P ALIGN="JUSTIFY">l</TD>
<TD WIDTH="89%" VALIGN="TOP"><P ALIGN="JUSTIFY">обеспечивает выдачу сообщения, если при записи не удается получить доступ ко всем файлам;</TD>
</TR>
<TR><TD WIDTH="11%" VALIGN="TOP"><P>m</TD>
<TD WIDTH="89%" VALIGN="TOP"><P>сообщает программе tar, что не следует изменять время модификации при записи файлов на ленту;</TD>
</TR>
<TR><TD WIDTH="11%" VALIGN="TOP"><P>v</TD>
<TD WIDTH="89%" VALIGN="TOP"><P>печать имен всех файлов и каталогов, при выполнении данной операции;</TD>
</TR>
<TR><TD WIDTH="11%" VALIGN="TOP"><P ALIGN="JUSTIFY">w</TD>
<TD WIDTH="89%" VALIGN="TOP"><P ALIGN="JUSTIFY">печатает наименование заданного действия и имя файла, после чего ожидается ответ пользователя. При "y" действие выполняется.</TD>
</TR>
<TR><TD WIDTH="11%" VALIGN="TOP"><P ALIGN="JUSTIFY">0,...,7</TD>
<TD WIDTH="89%" VALIGN="TOP"><P ALIGN="JUSTIFY">определяет номер устройства, на котором установлена лента, по умолчанию 1.</TD>
</TR>
</TABLE>

<P>Смена владельца файла chown</P>
<B><P>chown имя файл</P>
</B><P>Смена группы chgrp</P>
<B><P>chgrp группа файл</P>
</B><P>Изменение направления ввода/вывода</P>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=2 WIDTH=709>
<TR><TD WIDTH="18%" VALIGN="TOP"><P>&lt; &gt;</TD>
<TD WIDTH="82%" VALIGN="TOP"><P>задает направление ввода/вывода;</TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP"><P>&lt;&lt; &gt;&gt;</TD>
<TD WIDTH="82%" VALIGN="TOP"><P>задает направление, но добавляет к уже имеющемуся;</TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP"><P>|</TD>
<TD WIDTH="82%" VALIGN="TOP"><P>служит для передачи данных от одной команды к другой.</TD>
</TR>
</TABLE>

<B><P>tr [-cds][строка_1][строка_1]</P>
</B><P ALIGN="JUSTIFY">Считывает данные из стандартного ввода. Символы, не совпадающие с символом в аргументе "строка_1", передается на стандартный вывод без изменения. Символы же, совпадающие с символом в аргументе "строка_1", заменяются на соответствующие символы из аргумента "строка_2".</P>
<P>Асинхронное выполнение команд</P>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=2 WIDTH=709>
<TR><TD WIDTH="13%" VALIGN="TOP"><P>&amp;</TD>
<TD WIDTH="87%" VALIGN="TOP"><P>поставленное в конце командной строки позволяет продолжить работу, не дожидаясь окончания выполнения команды.</TD>
</TR>
</TABLE>

<P>wait&#9;вводится, когда нужно подождать завершения какого-то процесса.</P>
<P>Появление приглашения после ввода команды wait указывает на завершение всех запущенных ранее процессов.</P>

<B><P>at время [дата_и_время][приращение] список_команд</P>
</B><P>Команда планирования выполнения заданий.</P>
<P ALIGN="JUSTIFY">Позволяет выполнить команду в указанный день и час, которые могут модифицироваться необязательным приращением.</P>
<B><P>at -r идентификатор_задания</P>
</B><P>Отменяет запрос.</P>
<B><P>batch</B> планирует задания на то время, когда это будет позволять система.</P>
<P>Системные команды</P>
<B><P>mail имя файла или mail [-r] [-q] [-p] [-f файл]</P>
</B><P>Обращение к почтовому серверу.</P>
<P>Флаги:</P>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=2 WIDTH=709>
<TR><TD WIDTH="13%" VALIGN="TOP"><P>-f</TD>
<TD WIDTH="87%" VALIGN="TOP"><P>файл используется в качестве почтового ящика;</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P>-p</TD>
<TD WIDTH="87%" VALIGN="TOP"><P>печать почты;</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P>-q</TD>
<TD WIDTH="87%" VALIGN="TOP"><P>QUIT (прерывание процедуры);</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P>-r</TD>
<TD WIDTH="87%" VALIGN="TOP"><P>упорядочение - раньше посланное сообщение читается раньше; без флага - обратный порядок.</TD>
</TR>
</TABLE>

<P>При чтении почты можно пользоваться командами:</P>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=2 WIDTH=710>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>d</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>удаление данного почтового сообщения;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>m [имя]</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>переслать сообщение указанному пользователю;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>p</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>напечатать сообщение еще раз и вернуться к предшествующему сообщению;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>_</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>вернуться к предыдущему сообщению;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>s [файл]</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>записать сообщение в файл;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>ctrl/d</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>вернуть сообщение в почтовый ящик и завершить выполнение команды mail (= q).</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>x</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>выход без изменения почтового ящика;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>!</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>временный выход в SHELL;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>?</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>напечатать список команд mail.</TD>
</TR>
</TABLE>

<P>Сообщение всем работающим пользователям</P>
<B><P>wall </B>администратор что-то сообщает всем.</P>
<P>Конец сообщения по ctrl/d.</P>
<P>Посылка сообщения другому пользователю</P>
<B><P>write имя [терминал]</P>
</B><P>Разрешение или отмена сообщений</P>
<B><P>mesg [y] [n] (флаги - "y" и "n")</B> присылаемых другими пользователями.</P>
<P>Команды обработки файлов</P>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=2 WIDTH=709>
<TR><TD WIDTH="43%" VALIGN="TOP"><B><P ALIGN="JUSTIFY">comm [-[123]] файл1 файл2</B></TD>
<TD WIDTH="57%" VALIGN="TOP"><P ALIGN="JUSTIFY">поиск одинаковых и разных строк в файлах, флаги "123" обозначают номера колонок. Результат печатается в трех колонках:</TD>
</TR>
</TABLE>

<P>1 - строки встречаются только в файле1;<BR>
2 - строки встречаются только в файле2;<BR>
3 - строки встречаются в обоих файлах.</P>
<P>Преобразование файла</P>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=2 WIDTH=800>
<TR><TD WIDTH="25%" VALIGN="TOP"><B><P ALIGN="JUSTIFY">dd [аргументы]</B></TD>
<TD WIDTH="75%" VALIGN="TOP"><P ALIGN="JUSTIFY">позволяет задавать входной и выходной файлы, указывать виды преобразований. Обычно используется для магнитных лент.</TD>
</TR>
</TABLE>

<P>Аргументы:</P>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=2 WIDTH=800>
<TR><TD WIDTH="13%" VALIGN="TOP"><P>if=имя</TD>
<TD WIDTH="87%" VALIGN="TOP"><P>имя входного файла;</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P>of=имя</TD>
<TD WIDTH="87%" VALIGN="TOP"><P>имя выходного файла;</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P>ibs=n</TD>
<TD WIDTH="87%" VALIGN="TOP"><P>размер входного блока в байтах (512 по умолчанию);</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P>obs=n</TD>
<TD WIDTH="87%" VALIGN="TOP"><P>размер выходного блока (512 по умолчанию);</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P>bs=n</TD>
<TD WIDTH="87%" VALIGN="TOP"><P>размер входного и выходного блоков;</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P>cbs=n</TD>
<TD WIDTH="87%" VALIGN="TOP"><P>размер буфера преобразования в байтах;</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P>skip=n</TD>
<TD WIDTH="87%" VALIGN="TOP"><P>перед копированием пропустить n входных записей;</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P>files=n</TD>
<TD WIDTH="87%" VALIGN="TOP"><P>скопировать n файлов с входной ленты;</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P>seek=n</TD>
<TD WIDTH="87%" VALIGN="TOP"><P>установить выходной файл на запись с номером n перед началом 
копирования;</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P>count=n</TD>
<TD WIDTH="87%" VALIGN="TOP"><P>скопировать n входных записей.</TD>
</TR>
</TABLE>

<P>Поиск строк с заданным шаблоном</P>
<B><P>grep [флаг] ... выражение [файл]</P>
</B><P ALIGN="JUSTIFY">Служит для поиска соответствующих выражений (строк) в одном или нескольких файлах.</P>
<P>Флаги:</P>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=2 WIDTH=709>
<TR><TD WIDTH="27%" VALIGN="TOP"><P>-b</TD>
<TD WIDTH="73%" VALIGN="TOP"><P>перед каждой обнаруженной строкой печатается номер блока, где она содержится;</TD>
</TR>
<TR><TD WIDTH="27%" VALIGN="TOP"><P>-c</TD>
<TD WIDTH="73%" VALIGN="TOP"><P>печатается только число строк, содержащих шаблон;</TD>
</TR>
<TR><TD WIDTH="27%" VALIGN="TOP"><P>-e</TD>
<TD WIDTH="73%" VALIGN="TOP"><P>используется перед шаблоном, который начинается с символа "-";</TD>
</TR>
<TR><TD WIDTH="27%" VALIGN="TOP"><P>-h</TD>
<TD WIDTH="73%" VALIGN="TOP"><P>не печатаются имена файлов перед строками;</TD>
</TR>
<TR><TD WIDTH="27%" VALIGN="TOP"><P>-l</TD>
<TD WIDTH="73%" VALIGN="TOP"><P>печатаются имена файлов, содержащие искомые строки;</TD>
</TR>
<TR><TD WIDTH="27%" VALIGN="TOP"><P ALIGN="JUSTIFY">-n</TD>
<TD WIDTH="73%" VALIGN="TOP"><P ALIGN="JUSTIFY">перед каждой обнаруженной строкой печатается ее порядковый номер в файле;</TD>
</TR>
<TR><TD WIDTH="27%" VALIGN="TOP"><P ALIGN="JUSTIFY">-s</TD>
<TD WIDTH="73%" VALIGN="TOP"><P ALIGN="JUSTIFY">вырабатывается только статус результата выполнения команды;</TD>
</TR>
<TR><TD WIDTH="27%" VALIGN="TOP"><P>-v</TD>
<TD WIDTH="73%" VALIGN="TOP"><P>печатаются все строки, не содержащие шаблона;</TD>
</TR>
<TR><TD WIDTH="27%" VALIGN="TOP"><P>-y</TD>
<TD WIDTH="73%" VALIGN="TOP"><P>строчные буквы в шаблоне считаются совпадающими как со строчными, так и прописными в файле.</TD>
</TR>
<TR><TD WIDTH="27%" VALIGN="TOP"><B><P>egrep</B></TD>
<TD WIDTH="73%" VALIGN="TOP"><P>модифицированная версия grep.</TD>
</TR>
<TR><TD WIDTH="27%" VALIGN="TOP"><B><P ALIGN="JUSTIFY">fgrep</B></TD>
<TD WIDTH="73%" VALIGN="TOP"><P ALIGN="JUSTIFY">упрощенная версия команды grep. Ищет только фиксированные строки, но работает быстрее чем grep.</TD>
</TR>
</TABLE>

<P>Восьмеричный дамп файла</P>
<B><P>od[-флаги] файл[[+] смещение [.][b]].</P>
</B><P>Флаги:</P>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=2 WIDTH=709>
<TR><TD WIDTH="14%" VALIGN="TOP"><P>-b</TD>
<TD WIDTH="86%" VALIGN="TOP" COLSPAN=4><P>каждый байт файла интерпретируется как восьмеричное число;</TD>
</TR>
<TR><TD WIDTH="14%" VALIGN="TOP"><P ALIGN="JUSTIFY">-c</TD>
<TD WIDTH="86%" VALIGN="TOP" COLSPAN=4><P ALIGN="JUSTIFY">байты интерпретируются как символы ASCII, неграфические символы выдаются в виде:</TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP" COLSPAN=2><P>&nbsp;</TD>
<TD WIDTH="40%" VALIGN="TOP"><P>нулевой байт</TD>
<TD WIDTH="39%" VALIGN="TOP" COLSPAN=2><P>\0</TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP" COLSPAN=2><P>&nbsp;</TD>
<TD WIDTH="40%" VALIGN="TOP"><P>возврат на шаг</TD>
<TD WIDTH="39%" VALIGN="TOP" COLSPAN=2><P>\b</TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP" COLSPAN=2><P>&nbsp;</TD>
<TD WIDTH="40%" VALIGN="TOP"><P>перевод формата</TD>
<TD WIDTH="39%" VALIGN="TOP" COLSPAN=2><P>\f</TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP" COLSPAN=2><P>&nbsp;</TD>
<TD WIDTH="40%" VALIGN="TOP"><P>перевод строки</TD>
<TD WIDTH="39%" VALIGN="TOP" COLSPAN=2><P>\n</TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP" COLSPAN=2><P>&nbsp;</TD>
<TD WIDTH="48%" VALIGN="TOP" COLSPAN=2><P>возврат каретки</TD>
<TD WIDTH="31%" VALIGN="TOP"><P>\r</TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP" COLSPAN=2><P>&nbsp;</TD>
<TD WIDTH="48%" VALIGN="TOP" COLSPAN=2><P>горизонтальный TAB</TD>
<TD WIDTH="31%" VALIGN="TOP"><P>\t</TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP" COLSPAN=2><P>&nbsp;</TD>
<TD WIDTH="48%" VALIGN="TOP" COLSPAN=2><P>остальные </TD>
<TD WIDTH="31%" VALIGN="TOP"><P>ddd</TD>
</TR>
</TABLE>

<P>&nbsp;</P>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=2 WIDTH=709>
<TR><TD WIDTH="11%" VALIGN="TOP"><P>-d</TD>
<TD WIDTH="89%" VALIGN="TOP"><P>каждое слово интерпретируется как десятичное число;</TD>
</TR>
<TR><TD WIDTH="11%" VALIGN="TOP"><P>-o</TD>
<TD WIDTH="89%" VALIGN="TOP"><P>слова интерпретируются как восьмеричные числа;</TD>
</TR>
<TR><TD WIDTH="11%" VALIGN="TOP"><P>-x</TD>
<TD WIDTH="89%" VALIGN="TOP"><P>слова интерпретируются как шестнадцатеричные числа.</TD>
</TR>
</TABLE>

<P>Сохранение (зашита) файловой системы</P>
<B><P>dump [флаги[аргумент...] файловая система]</P>
</B><P ALIGN="JUSTIFY">Используется администратором для обеспечения сохранности всех данных в файловой системе.</P>
<P>Флаги:</P>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=2 WIDTH=710>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>d</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>задание плотности записи на ленту.</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>f</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>задает устройство для защиты;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>s</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>задание размера ленты;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>u</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>запись времени защиты;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>0-9</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>уровень защиты;</TD>
</TR>
</TABLE>

<P>Восстановление файловой системы</P>
<B><P>restor флаги [аргументы]</P>
</B><P>Чтение магнитных лент, записанных командой dump.</P>
<P>Разбиение файла на части</P>
<B><P>split [-n][файл[имя]]</P>
</B><P>разбивает файл на части по n строк (по умолчанию n=1000).</P>
<P ALIGN="JUSTIFY">Если задано имя выходного файла, то генерируется последовательность файлов с данным именем и буквами aa, ab, ac,... в конце. Если имя выходного файла не задано, используется имя "x".</P>

<P>Подсчет числа слов</P>
<B><P>wc[-lwc] [файл]</P>
</B><P ALIGN="JUSTIFY">Определяет число строк, слов и символов в одном или более файлов. Строки в файле разделяются символом "\n", слова - пробелами, горизонтальной табуляцией или переводом строки.</P>
<P>Флаги:</P>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=2 WIDTH=710>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>l</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>подсчет числа строк в файле;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>w</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>подсчет числа слов в файле;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>c</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>подсчет числа символов в файле;</TD>
</TR>
</TABLE>

<P>Вывод одинаковых строк файла</P>
<B><P>uniq [-флаги[+n][-n]][вход][выход]</P>
</B><P ALIGN="JUSTIFY">Находит одинаковые соседние строки файла. По умолчанию все одинаковые строки кроме одной удаляются.</P>
<P>Флаги:</P>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=2 WIDTH=710>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>c</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>одинаковые строки удаляются, но в начале строки ставится их исходное число;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>d</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>выводятся только одинаковые строки;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>-n</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>первые n полей при сравнении пропускаются;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>+n</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>перед сравнением пропускаются первые n символов;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>u</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>выводятся только разные строки.</TD>
</TR>
</TABLE>

<P>Обнаружение различий в файлах</P>
<B><P>diff[-флаги]файл1 файл2</P>
</B><P ALIGN="JUSTIFY">Определяются изменения, которые должны быть произведены в файлах, чтобы сделать их идентичными.</P>
<P>Позволяет экономить место при хранении ряда версий файла.</P>
<P>Флаги:</P>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=2 WIDTH=710>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>-b</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>игнорируются все пробелы и символы табуляции в конце строки, любые комбинации таких символов считаются эквивалентными;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>-e</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>выдает последовательность команд редактора ed, с помощью которых первый файл может быть сделан эквивалентным второму.</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>-f</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>вырабатывает список изменений;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>-h</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>быстро обнаруживает различия, но не всегда корректно.</TD>
</TR>
</TABLE>

<P>Сортировка и слияние файлов</P>
<P><B> sort[-флаги...][+поз1[-поз2]]...[-o имя][-T каталог][имя]...</B> </P>
<P>соединяет и сортирует файлы, помещает результат в заданный файл. Если ключ сортировки не задан, при сравнении используется вся строка.</P>
<P>Флаги:</P>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=2 WIDTH=800>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>b</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>при сравнении полей игнорируются пробелы и табуляции в начале строки;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>c</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>проверяется, отсортирован ли входной файл в соответствии с заданными правилами;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>d</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>"словарная сортировка": в сравнении участвуют только буквы, цифры и пробелы;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>f</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>прописные буквы воспринимаются как строчные;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>i</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>при нечисловых сравнениях игнорируются символы, не входящие в диапазон ASCII 040-0176;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>m</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>слияние файлов, которые предполагаются отсортированными;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>n</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>сортировка по арифметическому значению;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>o</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>имя, идущее после воспринимается как имя выходного файла;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>r</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>задается обратный порядок сортировки;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P ALIGN="JUSTIFY">tx</TD>
<TD WIDTH="80%" VALIGN="TOP"><P ALIGN="JUSTIFY">буква t указывает на то, что вместо принятого по умолчанию пробела в качестве разделителя используется горизонтальная табуляция;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>T</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>задает имя каталога, где размещаются временные файлы;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>u</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>если одному ключу соответствует несколько строк, выводится только одна из них.</TD>
</TR>
</TABLE>

<P>Управление выполнением программы</P>
<P>Вывод аргументов</P>
<P> <B> echo[-n][аргумент]</B> </P>
<P ALIGN="JUSTIFY">Выводит в стандартный файл заданные ей аргументы, разделяя их пробелами и завершая вывод переводом строки. Служит для сообщения о выполнении последовательности команд. Флаг -n предоставляет возможность отменить перевод строки после вывода аргументов.</P>
<P>Уничтожение процесса</P>
<P><B> kill [-флаг] процесс...</B> </P>
<P ALIGN="JUSTIFY">единственный флаг, допустимый в команде kill, - номер сигнала, например флаг -9 безусловно ликвидирует процесс.</P>
<P>Задержка выполнения команды</P>
<P><B> sleep время</B> </P>
<P>Задерживает выполнение команды на время, заданное в секундах.</P>
<P>Понижение приоритета команды</P>
<B><P>nice [-число]команда[аргументы]</P>

</B><P ALIGN="JUSTIFY">Позволяет выполнить другую команду, с более низким приоритетом. Аргумент-число определяет степень понижения приоритета. Чем больше число, тем меньше приоритет.</P>
<P>Дублирование стандартного вывода</P>
<B><P>tee [флаг]...[флаг]...</P>
</B><P ALIGN="JUSTIFY">команда читает информацию из стандартного ввода и выводит ее одновременно на терминал и в заданные файлы.</P>

<P>Флаги:</P>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=2 WIDTH=800>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>-i</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>игнорировать прерывания;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>-a</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>вывод будет добавлен к файлу, вместо принятого по умолчанию создания нового файла.</TD>
</TR>
</TABLE>

<P>Печать и установка времени</P>
<B><P>date [ггммддччмм][.сс]]</P></B>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=2 WIDTH=710>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>гг</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>год</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>мм</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>месяц</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>дд</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>день</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>чч</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>час</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>мм</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>минуты</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>сс</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>секунды</TD>
</TR>
</TABLE>

<P>Кто работает в системе?</P>
<B><P>who [файл] [am I]</P>
</B><P ALIGN="JUSTIFY">выдает список всех пользователей, работающих в данный момент, и имена их терминалов. [файл] - имя файла, где хранится информация о текущих пользователях. По умолчанию /etc/utmp. [am I] - дает возможность сообщить под каким именем вы вошли в систему.</P>
<P>Получение имени терминала</P>
<B><P>tty</B> печатает имя терминала, за которым вы работаете.</P>
<P>Состояние процессов</P>
<B><P>ps [флаг...][файл]</P>
</B><P>предоставляет информацию об активных процессах в системе.</P>
<P>Флаги:</P>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=2 WIDTH=710>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>a</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>выдается информация обо всех процессах, управляемых терминалами.</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>x</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>выдается информация обо всех процессах, не управляемых терминалами (системных).</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>l</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>выдается полная информация с указанием состояния каждого процесса.</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>PID</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>идентификатор процесса; </TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>TTY</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>номер терминала;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>CMD</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>команда, выполняемая процессом.</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>UID</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>идентификатор пользователя;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>PPID</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>идентификатор процесса, породившего данный процесс;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>CPU</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>системная составляющая приоритета процесса;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>PRI</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>приоритет процесса, чем больше, тем ниже;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>NICE</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>пользовательская составляющая приоритета процесса;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>ADDR</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>для резидентного процесса адрес в памяти, в противном случае на диске;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>SZ</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>размер образа процесса в блоках;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>WCHAN</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>событие, которого ожидает процесс с состоянием S или W; пустое поле означает, что процесс работает.</TD>
</TR>
</TABLE>

<BR>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=2 WIDTH=710>
<TR><TD WIDTH="20%" VALIGN="TOP"><B><P>pstat</B></TD>
<TD WIDTH="80%" VALIGN="TOP"><P>сообщает о статусе системы.</TD>
</TR>
</TABLE>

<P>Сведения об использовании диска</P>
<P><B> du[-s][-a][имя...]</B> </P>
<P>Флаги:</P>
<CENTER> <TABLE BORDER CELLSPACING=1 BORDERCOLOR="#000000" CELLPADDING=5 WIDTH=800>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>-s</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>выводит только общее количество блоков для всех файлов.</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>-a</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>печатает информацию для каждого файла.</TD>
</TR>
</TABLE></CENTER> 

<P>Сведения о свободных блоках на диске</P>
<B><P>df [файловая система]</P>
</B><P>выводит количество блоков, доступных в заданной файловой системе.<BR>
Определение типа файла<BR>
<B>file имя...</B> <BR>
Определяется тип файла: .OBJ, .C, ASCII и т.д.</P>
<P>Печать календаря</P>
<B><P>cal [месяц]год</P>
</B><P>Установка функций терминала</P>
<B><P>stty [аргументы...]</P>
</B><P ALIGN="JUSTIFY">позволяет узнать состояние любого терминала и настроить его на требуемый режим работы.</P>

<P>Аргументы:</P>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=2 WIDTH=800>
<TR><TD WIDTH="19%" VALIGN="TOP"><P>even</TD>
<TD WIDTH="81%" VALIGN="TOP"><P>включить контроль по четности;</TD>
</TR>
<TR><TD WIDTH="19%" VALIGN="TOP"><P>-even</TD>
<TD WIDTH="81%" VALIGN="TOP"><P>выключить контроль по четности;</TD>
</TR>
<TR><TD WIDTH="19%" VALIGN="TOP"><P>odd</TD>
<TD WIDTH="81%" VALIGN="TOP"><P>включить контроль на нечетность;</TD>
</TR>
<TR><TD WIDTH="19%" VALIGN="TOP"><P>raw</TD>
<TD WIDTH="81%" VALIGN="TOP"><P>включить прозрачный режим ввода;</TD>
</TR>
<TR><TD WIDTH="19%" VALIGN="TOP"><P>nl</TD>
<TD WIDTH="81%" VALIGN="TOP"><P>концом строки считать символ "перевода строки";</TD>
</TR>
<TR><TD WIDTH="19%" VALIGN="TOP"><P>-nl</TD>
<TD WIDTH="81%" VALIGN="TOP"><P>концом строки считать символ "возврат каретки";</TD>
</TR>
<TR><TD WIDTH="19%" VALIGN="TOP"><P>echo</TD>
<TD WIDTH="81%" VALIGN="TOP"><P>отображать на экране каждый вводимый символ;</TD>
</TR>
<TR><TD WIDTH="19%" VALIGN="TOP"><P>-echo</TD>
<TD WIDTH="81%" VALIGN="TOP"><P>не отображать вводимые символы;</TD>
</TR>
<TR><TD WIDTH="19%" VALIGN="TOP"><P>lcase</TD>
<TD WIDTH="81%" VALIGN="TOP"><P>преобразовывать прописные символы в строчные;</TD>
</TR>
<TR><TD WIDTH="19%" VALIGN="TOP"><P>tabs</TD>
<TD WIDTH="81%" VALIGN="TOP"><P>заменить символы табуляции на пробелы при выводе;</TD>
</TR>
<TR><TD WIDTH="19%" VALIGN="TOP"><P>erase</TD>
<TD WIDTH="81%" VALIGN="TOP"><P>установит следующий за erase символ в качестве символа стирания;</TD>
</TR>
<TR><TD WIDTH="19%" VALIGN="TOP"><P ALIGN="JUSTIFY">kill</TD>
<TD WIDTH="81%" VALIGN="TOP"><P ALIGN="JUSTIFY">установит следующий за kill символ в качестве символа отмены;</TD>
</TR>
</TABLE>

<P>Установка табуляции</P>
<B><P>tabs [аргументы]</B> </P>
<P>Устанавливает параметры табуляции для любого терминала.</P>
<P>Аргументы:</P>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=2 WIDTH=900>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>-n</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>используется, когда левое поле текста не выравнивается;</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P>терминал</TD>
<TD WIDTH="80%" VALIGN="TOP"><P>описывает тип рабочего терминала.</TD>
</TR>
</TABLE>

<BR>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=2 WIDTH=800>
<TR><TD WIDTH="33%" VALIGN="TOP"><B><P>uncompress</B></TD>
<TD WIDTH="67%" VALIGN="TOP"><P>разархивирует файлы, имеющие расширение .Z;</TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP"><B><P>uncompress имя_файла</B></TD>
<TD WIDTH="67%" VALIGN="TOP"><P>работает для файлов без расширения .Z.</TD>
</TR>
</TABLE>

<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=2 WIDTH=800>
<TR><TD WIDTH="33%" VALIGN="TOP"><B><P>uuencode файл указатель</B></TD>
<TD WIDTH="67%" VALIGN="TOP"><P ALIGN="JUSTIFY">используется для передачи двоичных (иногда и русских) файлов по электронной почте. Преобразует двоичный файл в ASCII-формат. Параметр указатель используется при декодировании и служит для указания маршрута и имени файла для команды uudecode. Результат кодировки можно положить в другой файл или непосредственно переслать по электронной 
почте.</TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP"><B><P ALIGN="JUSTIFY">uudecode файл</B></TD>
<TD WIDTH="67%" VALIGN="TOP"><P ALIGN="JUSTIFY">используется для передачи двоичных (иногда и русских) файлов по электронной почте. Преобразует двоичный файл в ASCII-формат. Параметр указатель используется при декодировании и служит для указания маршрута и имени файла для команды uudecode. Результат кодировки можно положить в другой файл или непосредственно переслать по электронной 
почте.</TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP"><B><P>nslookup</B></TD>
<TD WIDTH="67%" VALIGN="TOP"><P>выводит IP-информацию о домене;</TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP"><B><P>crypt</B></TD>
<TD WIDTH="67%" VALIGN="TOP"><P>кодирует файл по заданному пользователем ключу</TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP"><B><P>uuname</B></TD>
<TD WIDTH="67%" VALIGN="TOP"><P>выводит список узлов, известных данному узлу;</TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP"><B><P>uux</B></TD>
<TD WIDTH="67%" VALIGN="TOP"><P>выполняет команды на удаленной машине UNIX.</TD>
</TR>
</TABLE>








</TD></TR>

<TR bgcolor="steelblue"><TD VALIGN="TOP" bgcolor="steelblue" LINK="#0000FF"><P ALIGN="center">

<FONT color="white"><B> Previous: </B></FONT>
<A HREF="cab_1017.htm" tppabs="http://book.itep.ru/10/cab_1017.htm"><FONT COLOR="lightblue">10.17 Разводка разъемов</FONT></A>



<FONT color="white"><B> &nbsp; &nbsp;UP:</B></FONT>
<A HREF="adr_1011.htm" tppabs="http://book.itep.ru/10/adr_1011.htm"><FONT COLOR="lightblue">10.11 Адреса    серверов ведущих фирм, работающих в сфере телекоммуникаций</FONT></A>


<BR>



<FONT color="white"><B> &nbsp; &nbsp;Next:</B></FONT>
<A HREF="html1019.htm" tppabs="http://book.itep.ru/10/html1019.htm"><FONT COLOR="lightblue">10.19 Символьный набор HTML</FONT></A>

</TD>
  </TR>
</table>
</BODY>
</HTML>