<HTML><HEAD>
<!-- Meta http equivalent was here                                     -->
<META NAME="keywords" CONTENT="NTP
GMT
время






">
<TITLE>4.4.15 Сетевой протокол времени NTP</TITLE>
</HEAD>
<BODY background="gainsboro" tppabs="http://book.itep.ru/gainsboro" link="#0000FF">

<center>
<table BORDER="0" CELLSPACING="1" CELLPADDING="5" bgcolor="ghostwhite">
  <tr>
    <td VALIGN="TOP" bgcolor="steelblue" LINK="#0000FF"><p align="center">

<A HREF="snd_mail.htm" tppabs="http://book.itep.ru/4/4/snd_mail.htm">  <IMG ALIGN=BOTTOM ALT="previous" SRC="k_prev.jpg" tppabs="http://book.itep.ru/k_prev.jpg"></A>


<A HREF="rut_4411.htm" tppabs="http://book.itep.ru/4/44/rut_4411.htm">   <IMG ALIGN=BOTTOM ALT="up"   SRC="k_up.jpg" tppabs="http://book.itep.ru/k_up.jpg"></A>


<A HREF="proc_45.htm" tppabs="http://book.itep.ru/4/45/proc_45.htm"><IMG ALIGN=BOTTOM ALT="down" SRC="k_down.jpg" tppabs="http://book.itep.ru/k_down.jpg"></A>


<A HREF="sntp4416.htm" tppabs="http://book.itep.ru/4/44/sntp4416.htm"><IMG ALIGN=BOTTOM ALT="next" SRC="k_next.jpg" tppabs="http://book.itep.ru/k_next.jpg"></A>

<A HREF="intro1.htm" tppabs="http://book.itep.ru/1/intro1.htm">  <IMG ALIGN=BOTTOM ALT="index" SRC="k_indx.jpg" tppabs="http://book.itep.ru/k_indx.jpg"></A>
<BR>

<B> <FONT COLOR="white">Previous: </FONT></B>
<A HREF="snd_mail.htm" tppabs="http://book.itep.ru/4/4/snd_mail.htm"><FONT COLOR="lightblue">4.4.14.5 Программа Sendmail</FONT></A>


<B><FONT COLOR="white">&nbsp;&nbsp; UP:</FONT> </B>
<A HREF="rut_4411.htm" tppabs="http://book.itep.ru/4/44/rut_4411.htm"><FONT COLOR="lightblue">4.4.11 Протоколы    маршрутизации (обзор, таблицы маршрутизации, вектор расстояния)</FONT></A>
<BR>


<B><FONT COLOR="white"> Down:</FONT></B>
<A HREF="proc_45.htm" tppabs="http://book.itep.ru/4/45/proc_45.htm"><FONT COLOR="lightblue">4.5 Процедуры Интернет</FONT></A><BR>


<B><FONT COLOR="white">&nbsp; &nbsp; Next:</FONT></B>
<A HREF="sntp4416.htm" tppabs="http://book.itep.ru/4/44/sntp4416.htm"><FONT COLOR="lightblue">4.4.16 Протокол SNTP</FONT></A>

</TD></TR>
<TR><TD ALIGN=CENTER>   
<FONT color="#0000FF" size=6><B>4.4.15 Сетевой протокол времени NTP</B></FONT><br>
<FONT size=3>Семенов Ю.А. (ГНЦ ИТЭФ)</FONT></p>

</TD></TR>
<TR><TD>
<!--new-->
<P ALIGN="CENTER"><IMG SRC="sun_clk.jpg" tppabs="http://book.itep.ru/4/44/sun_clk.jpg"></P>

<P ALIGN="justify">Время – самый важный и невосполнимый ресурс любого человека. Проблема эта занимала людей всегда, и уже более 4 тысяч лет люди пытаются как-то упорядочить учет расходования этого ресурса, создавая различные календарные системы и устройства измерения времени. Календарные системы древнего мира отражали сельскохозяйственные, политические и ритуальные нужды, характерные
для того времени. Астрономические наблюдения для установления зимнего и летнего солнцестояния производились еще 4000 лет тому назад. Проблема создания календаря возникала только в обществах, где государственная стабильность поддерживалась в течение достаточно долгого времени (Китай, Египет, государство Майя). В 14-ом столетии до Рождества Христова в Китае была определена длительность солнечного года - 365.25 дней, а лунный месяц - 29.5
дней. Солнечно-лунный календарь действовал на ближнем востоке (за исключением Египта) и в Греции, начиная с 3-го тысячелетия до нашей эры. Ранние календари использовали либо 13 лунных месяцев по 28 дней или 12 месяцев с чередующейся протяженностью 29 и 30 дней.</p>

<p align="justify">Древнеегипетский календарь имел 12 30-дневных лунных месяцев, но был привязан к сезонному появлению звезды Сириус (sirius – sothis). Для того чтобы примирить этот календарь с солнечным годом, был изобретен гражданский календарь, в котором добавлено 5 дней, доводящих длительность года до 365 дней. Однако со временем было замечено, что гражданский год примерно на одну четверть дня короче, чем солнечный год. Выбранная длительность года обеспечивала полное совпадение с солнечным годом раз за 1460 лет. Этот период называется циклом Сотиса (sothic-цикл). Так же как и shang chinese, древние египтяне установили длительность солнечного года равной 365,25 дней, что с точностью 11 минут совпадает с результатами современных вычислений. В 432 году до рождества Христа, около столетия после китайцев греческий астроном Метон вычислил, что 110 лунных месяцев по 29 дней и 125 лунных месяцев по 30 дней соответствуют 6940 солнечным дням, что лишь немного превышает 19 лет. 19-летний цикл, названный циклом Метона, установил длительность лунного месяца равной 29,532 солнечных дней, что с точностью 2 минут совпадает результатами современных измерений.</p>

<p align="justify">В древнем Риме использовался лунный календарь. Юлий Цезарь пригласилалександрийского астронома Сосигенса, который разработал календарь (который по понятным причинам стал называться юлианским), принятый в 46 году до Рождества Христова. Календарь содержал 365 дней в году с добавлением одного дня каждые 4 года. Однако первые 36 лет по ошибке дополнительный день
добавлялся каждые три года. В результате набежало лишних три дня, которые пришлось компенсировать вплоть до 8 года нашей эры.</p>

<p align="justify">Семидневная неделя была введена лишь в четвертом столетии нашей эры императором Константином I.</p>

<p align="justify">Во время романской эры 15-летний цикл переписи использовался при исчислении налогов. Последовательность имен дней недели воспроизводится через 28 лет, этот период называется солнечным циклом. Таким образом, учитывая 28-летний солнечный цикл, 19-летний цикл Метона и 15-летний переписи, получаем суперцикл протяженностью 7980-лет, называемый юлианской эрой, которая начинается в 4713 году до рождества христова.</p>

<p align="justify">К 1545 году расхождение между юлианским календарем и солнечным годом достигло 10 дней. В 1582, астрономы Кристофер Клавиус и Луиджи Лилио предложили новую схему календаря. Папа Грегорий XIII выпусти указ, где среди прочего указывалось, что в году содержится 365.2422 дней.
Для того чтобы более точно аппроксимировать эту новую величину, только столетние годы, которые делятся без остатка на 400, объявляются високосными, что предполагает длительность года 365,2425 дней. В настоящее время григорианский календарь принят большинством стран мира.</p>

<p align="justify">Для того чтобы мерить расширение вселенной или распад протона необходимо стандартную схему нумерации дней. По решению Международного астрономического Союза был принят стандарт на секунду и юлианская система нумерации дней (jdn). Стандартный день содержит 86,400 стандартных секунд, а стандартный год состоит из 365,25 стандартных дней.</p>

<p align="justify">В схеме (JDN), предложенной в 1583 французским ученым Джозефом Юлиусом Скалигером, JDN 0.0 соответствует 12 часам (полдень) первого дня юлианской эры - 1 января 4713 до нашей эры. Годы до нашей эры подсчитываются согласно юлианскому календарю, в то время как годы нашей эры нумеруются по григорианскому календарю. 1 января 1 года после рождества
христова в григорианском календаре соответствует 3 января 1 года юлианского календаря [DER90], в JDN 1.721.426,0 день соответствует 12 часам первого дня нашей эры.</p>

<p align="justify">Калиброванный эталон времени, например атомные часы, довольно сложное и дорогостоящее устройство, требующее квалифицированного обслуживания. По этой причине многие пользователи не могут позволить себе такие издержки и вынуждены обращаться к услугам удаленных эталонов. Это может быть первичный эталон, размещенный где-то в локальной сети, или радио-часы.
Условия доступа к сети уже предполагают наличие определенной дисперсии для времени доставки калибровочной информации. Если же эталон размещен далеко в Интернет, значения задержки и дисперсии могут возрасти многократно. Для обеспечения большей надежности калибровки обычно используют
несколько эталонов, а для снижения влияния временных разбросов привлекают довольно сложные алгоритмы усреднения.</p>

<p align="justify">Сетевой протокол задания времени NTP (network time protocol; Network Time Protocol Version 3 Specification, Implementation and Analysis, David L. Mills, RFC-1305, March 1992) служит для осуществления синхронизации работы различных процессов в серверах и программах клиента. Он определяет архитектуру, алгоритмы, объекты и протоколы, используемые для указанных
целей. NTP был впервые определен в документе RFC-958 [MIL85c], но с тех пор несколько раз переделан и усовершенствован (RFC-1119 [MIL89]). Протокол использует для транспортных целей UDP [POS80]. Целью протокола является обеспечение максимально возможной точности и надежности, несмотря на значительный разброс задержек при прохождении через большое число промежуточных
маршрутизаторов.</p>

<p align="justify">Протокол NTP обеспечивает механизмы синхронизации с точностью до наносекунд. Протокол предлагает средства для определения характеристик и оценки ошибок локальных часов и временного сервера, который осуществляет синхронизацию. Предусмотрены возможности работы с
иерархически распределенными первичными эталонами, такими как синхронизуемые радио-часы.</p>

<p align="justify">Точность, достижимая с помощью NTP, сильно зависит от точности локальных часов и характерных скрытых задержек. Алгоритм коррекции временной шкалы включает внесение задержек, коррекцию частоты часов и ряд механизмов, позволяющих достичь точности порядка нескольких миллисекунд, даже после длительных периодов, когда потеряна связь с синхронизирующими источниками.</p>

<p align="justify">Существует ряд механизмов в Интернет, которые позволяют передавать и записывать время, когда произошло какое-то событие. Это протокол daytime [POS83a], time protocol [POS83b], сообщения ICMP “временная метка” [DAR81b] и опция IP “временная метка” [SU81].</p>

<p align="justify">Маршрутный протокол fuzzball [MIL83b], иногда называемый hellospeak, встраивает синхронизацию непосредственно в алгоритм маршрутного протокола. Он не является протоколом из стека IP.</p>

<p align="justify">Юниксовский (4.3BSD) времязадающий демон [GUS85a] измеряет временные сдвиги различных клиентских процессов и рассылает им соответствующие поправки.</p>

<p align="justify">В этой модели сервер определен с помощью алгоритма выбора [GUS85b], который исключает ситуации, где сервер не выбран или выбрано более одного сервера. Процесс выбора требует возможности рассылки широковещательных сообщений.</p>

<p align="center"><b> Архитектура системы</b> </p>
<p align="center"><img src="ntp0.jpg" tppabs="http://book.itep.ru/4/44/ntp0.jpg"></p>

<p align="justify">В модели NTP некоторое число первичных эталонов времени, синхронизованных по кабелю или с помощью национальных радио служб времени, подключено к широкодоступным ресурсам, таким как порты опорной сети. Эти устройства функционируют как первичные серверы времени. Целью NTP является передача информации о точном времени от этих серверов к другим серверам через Интернет и коррекция ошибок, связанных с флуктуациями задержек в сети. Некоторое число локальных ЭВМ или внешних шлюзов могут выполнять функции вторичных серверов времени, общающихся с первичными эталонами на основе протокола NTP. Вторичные серверы позволяют минимизировать избыточность
протокола, рассылая нужную временную информацию локально. В целях обеспечения надежности выбранные вторичные источники могут быть снабжены менее точными, зато более дешевыми радио-часами, используемыми в ситуациях, когда откажет первичный эталон или выйдет из строя ведущий к нему канал.</p>

<p align="justify">Под стабильностью подразумевается степень постоянства задающей частоты часов, а под точностью – соответствие этой частоты национальным стандартам времени. Если не указано обратного, под временным сдвигом между часами подразумевается разница показаний этих часов. В то время как под сбоем (skew) подразумевается различие их рабочих частот (первая производная). Настоящие часы имеют конечную стабильность частоты (вторая производная не равна нулю). Нестабильность частоты называется дрейфом, но в рамках протокола NTP дрейф предполагается равным нулю.</p>

<p align="justify">Протокол NTP создан с целью определения трех величин: смещения часов (clock offset), RTT и дисперсии, все они вычисляются по отношению к выбранным эталонным часам. Смещение часов определяет поправку, которую необходимо внести в показания местных часов, чтобы результат
совпал показанием эталонных часов. Дисперсия характеризует максимальную ошибку локальных часов по отношению к эталонным.</p>

<p align="justify">В протоколе NTP нет средств для нахождения партнера или управления. Целостность данных обеспечивается с помощью IP и UDP контрольных сумм. Система может работать в симметричном режиме, когда сервер и клиент неразличимы, и в режиме клиент-сервер, где сервер выполняет только
то, что требует клиент. Используется только один формат сообщений NTP. В рамках модели необходимо определить минимально возможную частоту коррекций часов, обеспечивающую требуемую временную точность.</p>

<p align="justify"><b> Реализация модели</b> </p>

<p align="justify">Клиент посылает NTP-сообщения одному или нескольким серверам и обрабатывает отклики по мере их получения. Сервер изменяет адреса и номера портов, переписывает содержимое некоторых полей, заново вычисляет контрольную сумму и немедленно посылает отклик. Информация, заключенная в сообщение NTP, позволяет клиенту определить показания часов сервера по отношению к
часам клиента и соответствующим образом скорректировать рабочие параметры местных часов. Кроме того, эта информация содержит данные, позволяющие оценить точность и надежность часов сервера и выбрать наилучший эталон времени.</p>

<p align="justify">Модель клиент-сервер может быть вполне достаточна для локальных сетей, где один сервер обслуживает некоторое количество клиентов. В общем случае NTP требует одновременной работы большого числа распределенных пар партнеров (клиент-сервер), конфигурация которых изменяется динамически. Нужны достаточно сложные алгоритмы управления такой ассоциацией, для обработки данных
и контроля множества локальных часов.</p>

<p align="justify">Процесс передачи, управляемый независимыми таймерами для каждого из партнеров, осуществляет накопление информации в базе данных и посылает сообщения NTP. Каждое сообщение содержит локальную временную метку момента отправки сообщения, ранее полученные временные метки,
а также необходимую вспомогательную информацию. Частота посылки сообщений определяется требуемой точностью локальных часов, а также предельными точностями часов партнеров.</p>

<p align="justify">Процесс приема осуществляет получение сообщений NTP и, возможно, сообщений других протоколов, а также информации от непосредственно подключенных радио-часов. Когда получено сообщение NTP, вычисляется сдвиг между часами партнера и локальными часами, результат заносится в базу данных вместе с другой информацией, необходимой для вычисления ошибок и выбора партнера.</p>

<p align="justify"><b> Конфигурации сети</b> </p>

<p align="justify">Субсеть синхронизации представляет собой соединение первичных и вторичных серверов времени, клиентов и каналов передачи данных. Первичные серверы времени синхронизованы непосредственно от эталонов времени, обычно от радио-часов. Вторичные серверы могут быть синхронизованы от первичных серверов или других вторичных серверов времени. Система серверов имеет иерархическую структуру, построенную по схеме клиент-сервер. Понятно, что вторичные серверы обеспечивают более низкую временную точность.</p>

<p align="justify">Следуя принципам, принятым в телефонной промышленности [BEl86], точность каждого сервера определяется номером слоя (stratum), наивысший уровень (для первичного сервера) имеет номер 1. На современном уровне технологий (радио-часы) точность однократной сверки имеет порядок одной миллисекунды.</p>

<p align="justify">Точность однократной сверки падает по мере роста значения RTT и его разброса. Для того чтобы избежать сложных расчетов [BRA80], необходимых для оценки точности в каждом конкретном случае, полезно предположить, что средняя ошибка измерения пропорциональна RTT и ее
дисперсии. Предполагая, что первичные серверы синхронизованы стандартами времени с известной точностью, можно получить вполне надежную оценку точности синхронизации субсети.</p>

<p align="justify">Дополнительным фактором является то, что каждый переход от одного слоя к другому предполагает наличие ненадежного сервера времени, который вносит дополнительные ошибки. Алгоритм выбора серверов времени использует разновидность алгоритма маршрутизации <a href="rip44111.htm#point1" tppabs="http://book.itep.ru/4/44/rip44111.htm#point1">Беллмана-Форда</a>, при этом формируется дерево минимальных весов, основанием которого являются первичные сервера. Метрикой расстояния служит номер слоя плюс расстояние синхронизации, которое характеризуется суммой дисперсии и половины абсолютного значения задержки.</p>

<p align="justify">Такая конструкция способствует тому, что субсеть автоматически реконфигурируется и настраивается на максимально достижимую точность даже при выходе из строя первичных или вторичных серверов времени. Если даже все первичные серверы выйдут из строя или станут недоступными, их функции будут выполнять вторичные серверы, если расстояние до них
согласно алгоритму Беллмана-Форда не превышает значения метрики, соответствующего бесконечности (разрыву связи). Если все серверы окажутся на больших расстояниях, субсеть продолжит работу при установках, выполненных при последней синхронизации (коррекции внутренних часов). Даже в этом
случае достижима точность порядка миллисекунд в сутки.</p>

<p align="justify">Если два сервера находятся согласно алгоритму на равных расстояниях, допускается случайный выбор.</p>

<p align="justify"><b> Форматы данных</b> </p>

<p align="justify">Все арифметические операции в рамках протокола выполняются в формате с фиксированной запятой. По этой причине все переменные в NTP имеют именно этот формат. Биты пронумерованы слева на право (со старшего бита), начиная с нуля. Жестких требований на число разрядов после запятой не установлено. Если не оговорено обратного, все числа не имеют знака и
занимают все отведенное для них поле (при необходимости в качестве заполнителей старших разрядов используются нули).</p>

<p align="justify">Временные метки NTP представляют собой 64-битные числа с фиксированной запятой без знака, которое указывает число секунд с нуля часов 1-го января 1900 года. Целая часть содержит первые 32 разряда, а дробная часть остальные 32 разряда. Этот формат не совпадает с форматом меток ICMP, где время измеряется в миллисекундах. Точность представления составляет 200
пикосекунд, что должно удовлетворить самым экзотическим требованиям.</p>

<p align="justify">Временная метка формируется путем копирования показания местных часов. Это производится в момент времени, заданный каким-то событием, например, приходом сообщения. Для поддержания наивысшей точности, важно, чтобы это делалось как можно ближе к оборудованию или программному обеспечению, инициирующего этот процесс. В случае, когда временная метка недоступна,
например, производится перезагрузка машин, поле метки характеризуется 64 нулями.</p>

<p align="justify">Заметим, что с 1968 года старший бит (бит 0 целой части) равен единице, а где-то <b>в 2036 году 64-битовое поле переполнится</b>.</p>

<p align="justify"><b> Переменные состояния и параметры</b> </p>

<p align="justify">Ниже приводится обзор различных переменных и параметров, используемых протоколом. Они распределены по классам системных переменных, которые имеют отношение к операционной среде и механизму реализации местных часов. Сюда входят переменные партнеров, которые характеризуют состояние протокольных машин участников обмена, переменные пакетов, описывающие содержимое пересылаемых NTP-сообщений, а также параметры, задающие конфигурацию
текущей версии программного обеспечения. Имена переменных записываются строчными буквами, а имена параметров - прописными.</p>

<p align="justify"><b> Общие переменные</b> </p>

<p align="justify">Следующие переменные являются общими для двух или более систем, партнеров и классов пакетов. Когда необходимо отличить общие переменные с идентичными именами, вводится идентификатор переменной.</p>

<p align="justify"><b><i> Адрес партнера</i> </b>(peer.peeraddr, pkt.peeraddr), порт партнера (peer.peerport, pkt.peerport). 32-битный ip-адрес и 16-битный номер порта партнера.</p>

<p align="justify"><b><i> Адрес ЭВМ</i></b> (peer.hostaddr, pkt.hostaddr), порт ЭВМ (peer.hostport, pkt.hostport). 32-битный IP-адрес и 16-битный номер порта ЭВМ. Эти переменные включаются в переменные состояния для поддержки мультиинтерфейсных систем.</p>

<p align="justify"><b><i> Индикатор приращения</i> </b>(sys.leap, peer.leap, pkt.leap) - это двухбитный код предупреждения о включении дополнительных секунд во временную шкалу NTP. Эти биты устанавливаются до 23:59 дня добавления и сбрасываются после 00:00 следующего дня. В результате день, для которого проведена эта процедура, окажется длиннее или короче на одну секунду. Для
вторичных серверов эти биты устанавливаются протоколом NTP. Биты 0 и 1 (LI) принимают значения, перечисленные в таблице 4.4.15.1:</p>

<b><p align="center">Таблица 4.4.15.1 Значения кодов индикатора LI </p></b>

<center> <table border=10 cellspacing=1 cellpadding=5 width=600 bgcolor="ghostwhite">
<tr><td width="13%" valign="top" bgcolor="gainsboro"><p align="center">LI</td>
<td width="18%" valign="top" bgcolor="gainsboro"><p align="center">Величина</td>
<td width="69%" valign="top" bgcolor="gainsboro"><p align="justify">Значение</td>
</tr>
<tr><td width="13%" valign="top"><p align="center">00</td>
<td width="18%" valign="top"><p align="center">0</td>
<td width="69%" valign="top"><p align="justify">предупреждения нет</td>
</tr>
<tr><td width="13%" valign="top"><p align="center">01</td>
<td width="18%" valign="top"><p align="center">1</td>
<td width="69%" valign="top"><p align="justify">последняя минута содержит 61 секунду</td>
</tr>
<tr><td width="13%" valign="top"><p align="center">10</td>
<td width="18%" valign="top"><p align="center">2</td>
<td width="69%" valign="top"><p align="justify">последняя минута содержит 59 секунд </td>
</tr>
<tr><td width="13%" valign="top"><p align="center">11</td>
<td width="18%" valign="top"><p align="center">3</td>
<td width="69%" valign="top"><p align="justify">аварийный сигнал (часы не синхронизованы)</td>
</tr>
</table></center>

<p align="justify">Во всех случаях за исключением аварийного сигнала (alarm = 112), протокол NTP никак не изменяет эти биты, а только передает их программам преобразования времени, которые не являются частью протокола. Аварийная ситуация возникает, когда по какой-либо причине локальные часы оказываются не синхронизованными. Это может случиться в ходе инициализации
системы или в случае, когда первичные часы оказываются недоступны в течение длительного времени.</p>

<p align="justify"><b><i> Режим</i> (peer.mode, pkt.mode) </b>  - это целое 3-битовое число, обозначающее код режима ассоциации, который может принимать значения, приведенные в таблице 4.4.15.2:</p>

<p align="center">Таблица 4.4.15.2. Значения кодов <i> Режим</i> </p>

<center> <table border=10 cellspacing=1 cellpadding=5 width=600 bgcolor="ghostwhite">
<tr><td width="13%" valign="top" bgcolor="gainsboro"><p align="center">Режим</td>
<td width="87%" valign="top" bgcolor="gainsboro"><p align="justify">Значение</td>
</tr>
<tr><td width="13%" valign="top"><p align="center">0</td>
<td width="87%" valign="top"><p align="justify">зарезервировано</td>
</tr>
<tr><td width="13%" valign="top"><p align="center">1</td>
<td width="87%" valign="top"><p align="justify">симметричный активный</td>
</tr>
<tr><td width="13%" valign="top"><p align="center">2</td>
<td width="87%" valign="top"><p align="justify">симметричный пассивный</td>
</tr>
<tr><td width="13%" valign="top"><p align="center">3</td>
<td width="87%" valign="top"><p align="justify">клиент</td>
</tr>
<tr><td width="13%" valign="top"><p align="center">4</td>
<td width="87%" valign="top"><p align="justify">сервер</td>
</tr>
<tr><td width="13%" valign="top"><p align="center">5</td>
<td width="87%" valign="top"><p align="justify">широковещательный</td>
</tr>
<tr><td width="13%" valign="top"><p align="center">6</td>
<td width="87%" valign="top"><p align="justify">для управляющих сообщений NTP</td>
</tr>
<tr><td width="13%" valign="top"><p align="center">7</td>
<td width="87%" valign="top"><p align="justify">зарезервировано для частного использования</td>
</tr>
</table></center>

<p align="justify"><b><i> Слой</i> (sys.stratum, peer.stratum, pkt.stratum) -</b> это целое число, указывающее код слоя локальных часов, который может принимать значения приведенные в таблице 4.4.15.3.</p>

<p align="center">Таблица 4.4.15.3. Значения кодов <i>слой</i> </p>

<center> <table border=10 cellspacing=1 cellpadding=5 width=600 bgcolor="ghostwhite">
<tr><td width="18%" valign="top" bgcolor="gainsboro"><p align="center">Слой</td>
<td width="82%" valign="top" bgcolor="gainsboro"><p align="justify">Значение</td>
</tr>
<tr><td width="18%" valign="top"><p align="center">0</td>
<td width="82%" valign="top"><p align="justify">Не специфицирован или недоступен </td>
</tr>
<tr><td width="18%" valign="top"><p align="center">1</td>
<td width="82%" valign="top"><p align="justify">Первичный эталон (например, радио часы)</td>
</tr>
<tr><td width="18%" valign="top"><p align="center">2-15</td>
<td width="82%" valign="top"><p align="justify">Вторичный эталон (через NTP или sntp)</td>
</tr>
<tr><td width="18%" valign="top"><p align="center">16-255</td>
<td width="82%" valign="top"><p align="justify">Зарезервировано на будущее</td>
</tr>
</table></center>

<p align="justify">Для целей сравнения значение нуль для кода слоя считается выше, чем любая
другая величина. Заметим, что максимальное значение целого, закодированное как пакетная переменная,
ограничено параметром ntp.maxstratum.</p>

<p align="justify"><b><i>Период обмена</b></i> (sys.poll, peer.hostpoll, peer.peerpoll, pkt.poll). Это целая переменная со знаком, указывающая минимальный интервал между передаваемыми сообщениями, измеренный в секундах и представленный как степень 2. Например, значение 6 указывает на
минимальный интервал в 64 секунды.</p>

<p align="justify"><b><i>Точность</i> </b>(sys.precision, peer.precision, pkt.precision). Это целая переменная со знаком, обозначающая точность часов в секундах и выраженная как ближайшая степень числа 2. Значение должно быть округлено в большую сторону до ближайшего значения степени
2, например, сетевой частоте 50-Гц (20 мс) или 60-Гц (16.67 мс) будет поставлено в соответствие величина -5 (31.25 мс), в то время как кварцевой частоте 1000-Гц (1 мс) будет поставлено в соответствие значение -9 (1.95 мс).</p>

<p align="justify"><b><i>Базовая задержка</i> </b>(sys.rootdelay, peer.rootdelay, pkt.rootdelay). Это число с фиксированной запятой со знаком, указывающее на величину полной циклической задержки (RTT) до первичного эталона частоты, выраженной в секундах.</p>

<p align="justify"><b><i>Базовая дисперсия</i> </b>(sys.rootdispersion, peer.rootdispersion, pkt.rootdispersion). Это число с фиксированной запятой больше нуля, указывающее на максимальное значение временной ошибки  по отношению к первичному эталону в секундах.</p>

<p align="justify"><b><i>Идентификатор эталонных часов</i> </b>(sys.refid, peer.refid, pkt.refid). Это 32-битовый код, идентифицирующий конкретные эталонные часы. В случае слоя 0 (не специфицирован) или слоя 1 (первичный эталонный источник), 4-октетная ASCII-строка, выровненная по левому краю и
дополненная при необходимости нулями, например:</p>

<p align="center">Таблица 4.4.15.4. Коды идентификаторов часов </p>

<p align="center"><center><table border=10 cellspacing=1 cellpadding=5 width=700 bgcolor="ghostwhite">
<tr><td width="15%" valign="top" bgcolor="gainsboro"><b><p align="center">Слой</b></td>
<td width="18%" valign="top" bgcolor="gainsboro"><b><p align="center">Код</b></td>
<td width="67%" valign="top" bgcolor="gainsboro"><b><p align="justify">Значение</b></td>
</tr>
<tr><td width="15%" valign="top"><b><p align="center">0</b></td>
<td width="18%" valign="top"><p align="center">dcn</td>
<td width="67%" valign="top"><p align="justify">Протокол маршрутизации dcn</td>
</tr>
<tr><td width="15%" valign="top"><b><p align="center">0</b></td>
<td width="18%" valign="top"><p align="center">dts</td>
<td width="67%" valign="top"><p align="justify">Цифровая служба времени (digital time service)</td>
</tr>
<tr><td width="15%" valign="top"><b><p align="center">0</b></td>
<td width="18%" valign="top"><p align="center">nist</td>
<td width="67%" valign="top"><p align="justify">Общий модем nist </td>
</tr>
<tr><td width="15%" valign="top"><b><p align="center">0</b></td>
<td width="18%" valign="top"><p align="center">tsp</td>
<td width="67%" valign="top"><p align="justify">Временной протокол tsp</td>
</tr>
<tr><td width="15%" valign="top"><b><p align="center">1</b></td>
<td width="18%" valign="top"><p align="center">atom</td>
<td width="67%" valign="top"><p align="justify">Атомные часы (калиброванные)</td>
</tr>
<tr><td width="15%" valign="top"><b><p align="center">1</b></td>
<td width="18%" valign="top"><p align="center">vlf</td>
<td width="67%" valign="top"><p align="justify">vlf-радио (omega, и пр.)</td>
</tr>
<tr><td width="15%" valign="top"><b><p align="center">1</b></td>
<td width="18%" valign="top"><p align="center">callsign</td>
<td width="67%" valign="top"><p align="justify">Общее радио</td>
</tr>
<tr><td width="15%" valign="top"><b><p align="center">1</b></td>
<td width="18%" valign="top"><p align="center">gps</td>
<td width="67%" valign="top"><p align="justify">gps УВЧ позиционирование спутников </td>
</tr>
<tr><td width="15%" valign="top"><b><p align="center">1</b></td>
<td width="18%" valign="top"><p align="center">lorc</td>
<td width="67%" valign="top"><p align="justify">loran-c радионавигация</td>
</tr>
<tr><td width="15%" valign="top"><b><p align="center">1</b></td>
<td width="18%" valign="top"><p align="center">wwvb</td>
<td width="67%" valign="top"><p align="justify">Радио wwvb НЧ (диапазон 5) </td>
</tr>
<tr><td width="15%" valign="top"><b><p align="center">1</b></td>
<td width="18%" valign="top"><p align="center">goes</td>
<td width="67%" valign="top"><p align="justify">Спутник goes УВЧ (диапазон 9)</td>
</tr>
<tr><td width="15%" valign="top"><b><p align="center">1</b></td>
<td width="18%" valign="top"><p align="center">wwv</td>
<td width="67%" valign="top"><p align="justify">Радио wwv ВЧ (диапазон 7) </td>
</tr>
</table>
</center></p>

<p align="justify">В случае слоя 2 и выше (вторичный эталон) - это 4-октетный IP-адрес партнера, выбранного для синхронизации.</p>

<p align="justify"><b><i> Эталонная временная метка</i> (sys.reftime, peer.reftime, pkt.reftime) -</b> локальное время в формате временных меток, соответствующее моменту последней коррекции показаний часов. Если локальные часы не были синхронизованы, переменная содержит нуль.</p>

<p align="justify"><b><i> Базовая временная метка</i> (peer.org, pkt.org) -</b> локальное время в формате временных меток, соответствующее моменту посылки последнего NTP-сообщения. Если партнер недостижим, переменная принимает нулевое значение.</p>

<p align="justify"><b><i> Временная метка получения</i> (peer.rec, pkt.rec) -</b> локальное время в формате временных меток, соответствующее моменту прихода последнего NTP-сообщения, полученного от партнера. Если партнер недостижим, переменная принимает нулевое значение.</p>

<p align="justify"><b><i> Временная метка передачи</i> (peer.xmt, pkt.xmt) -</b> локальное время в формате временных меток, соответствующее моменту отправки NTP-сообщения.</p>

<p align="justify"><b> Системные переменные</b> </p>

<p align="justify">Следующие переменные используются операционной системой для синхронизации локальных часов.</p>

<p align="justify">Переменная <b><i> локальные часы</i> (sys.clock)</b> содержит показание локальных часов в формате временных меток. Локальное время получается от аппаратных часов конкретной ЭВМ и дискретно увеличивается с конструктивно заданными приращениями.</p>

<p align="justify">Переменная <b><i>Базовые часы</i> (sys.peer)</b> представляет собой селектор, идентифицирующий используемый источник синхронизации. Обычно это указатель на структуру, содержащую переменные партнера. Значение нуль указывает, что в настоящее время источник
синхронизации отсутствует.</p>

<p align="justify"><b>Переменные партнера</b> </p>

<p align="justify">Ниже перечислены все переменные партнера, которые используются для управления и реализации измерительных процедур. </p>

<p align="justify"><b><i> Бит конфигурации</i> (peer.config)</b> - бит, индицирующий, что ассоциация была сформирована на основе конфигурационной информации и не должна быть расформирована, когда партнер становится недоступен.</p>

<p align="justify"><b><i> Временная метка актуализации</i> (peer.update) - </b>локальное время в формате временной метки, отмечающее момент, когда было получено последнее NTP сообщение. Переменная используется для вычисления дисперсии временного сдвига.</p>

<p align="justify"><b><i> Регистр достижимости</i> (peer.reach) -</b> сдвиговый регистр битов ntp.window, используемых для определения статуса достижимости партнера. Ввод данных производится со стороны младших бит (справа). Партнер считается достижимым, если как минимум один бит этого регистра равен 1.</p>

<p align="justify"><b><i> Таймер партнера</i> (peer.timer) - </b>целочисленный счетчик, используемый для управления интервалом между последовательно посылаемыми NTP-сообщениями. После установки значения счетчика его содержимое уменьшается на 1 (1сек) пока не достигнет нуля. При этом вызывается процедура передачи. Заметим, что работа этого таймера не должна зависеть от локальных часов.</p>

<p align="justify"><b> Пакетные переменные</p>

<p align="justify"><i> Номер версии</i> (pkt.version) -</b> целое число индицирующее номер версии отправителя. NTP сообщения всегда посылаются с текущим значением версии ntp.version и будут восприняты лишь при условии совпадения кодов версии (ntp.version). Исключения допускаются лишь при смене
номера версии.</p>

<p align="justify"><b> Переменные фильтра часов</b> </p>

<p align="justify">Когда используются фильтры и алгоритмы отбора, дополнительно привлекаются следующие переменные состояния.</p>

<p align="justify"><b><i> Регистр фильтра</i> (peer.filter) -</b> сдвиговый регистр каскадов ntp.shift, где каждый каскад запоминает значения измеренной задержки, смещения и вычисленной дисперсии, соответствующих одному наблюдению. Эти три параметра вводятся со стороны старших разрядов и сдвигаются в направлении младших разрядов (направо). При получении результатов нового
наблюдения старые результаты теряются.</p>

<p align="justify"><b><i> Счетчик корректных данных</i> (peer.valid) -</b> целочисленный счетчик, указывающий на корректные образцы, остающиеся в регистре фильтра. Он используется для определения состояния доступности и для управления увеличением и уменьшением периода рассылки сообщений.</p>

<p align="justify"><b><i> Смещение</i> (peer.offset) -</b> число с фиксированной запятой со знаком, индицирующее значение смещение часов партнера по отношению к локальным часам в секундах.</p>

<p align="justify"><b><i> Задержка</i> (peer.delay) -</b> число с фиксированной запятой со знаком, индицирующее полную циклическую задержку (RTT) часов партнера по отношению к локальным часам с учетом времени распространения сообщения и отклика в сети в секундах. Заметим, что переменная может принимать как положительное, так и отрицательное значение в зависимости от точности часов и накопившейся ошибки смещения.</p>

<p align="justify"><b><i> Дисперсия</i> (peer.dispersion) - </b> число с фиксированной запятой, индицирующее максимальную ошибку часов партнера по отношению к локальным часам с учетом сетевой задержки в секундах. Допускаются только значения больше нуля.</p>

<p align="justify"><b> Переменные аутентификации</b> </p>

<p align="justify">При использовании механизма аутентификации привлекаются следующие переменные состояния.</p>

<p align="justify"><b><i>Бит разрешения аутентификации</i> (peer.authenable) -</b> бит, указывающий, что ассоциация должна работать в режиме аутентификации.</p>

<p align="justify"><b><i>Бит аутентификации</i> (peer.authentic) -</b> бит, индицирующий то, что последнее сообщение, полученное от партнера, было корректно аутентифицировано.</p>

<p align="justify"><b><i>Идентификатор ключа</i> (peer.hostkeyid, peer.peerkeyid, pkt.keyid) -</b> целое число, идентифицирующее криптографический ключ, использованный при генерации аутентификационного кода сообщения.</p>

<p align="justify"><b><i>Криптографические ключи</i> (sys.key) -</b> набор 64-битных ключей DES. Каждый ключ создается в соответствии с берклиевскими UNIX-распределениями, которые состоят из 8 октетов, где 7 младших бит каждого октета соответствуют битам des 1-7, а старший бит соответствует
биту четности DES.</p>

<p align="justify"><b><i>Контрольная крипто-сумма</i> (pkt.check) -</b> криптографическая контрольная сумма, вычисляемая процедурой шифрации.</p>

<p align="justify"><b>Параметры</b></p>

<p align="justify">Ниже описаны параметры для всех реализаций, работающих в сети Интернет. Необходимо договориться относительно значений этих параметров для того, чтобы исключить ненужную избыточность и стабилизировать ассоциации партнеров. Приведенные параметры применимы для всех
ассоциаций.</p>

<p align="justify"><b><i>Номер версии</i> (ntp.version) -</b> текущий номер версии NTP (3).</p>

<p align="justify"><b><i>Порт NTP</i> (ntp.port) -</b> стандартный номер порта (123), присвоенный протоколу NTP.</p>

<p align="justify"><b><i>Максимальный номер слоя</i> (ntp.maxstratum) -</b> максимальный номер слоя, который может быть использован при кодировании пакетной переменной. Этот параметр обычно интерпретируется как определение бесконечности (недостижимости для протокола маршрутизации в субсети).</p>

<p align="justify"><b><i>Максимальный возраст часов</i> (ntp.maxage) -</b> максимальный интервал в секундах, в течение которого эталонные часы будут рассматриваться корректными после последней сверки.</p>

<p align="justify"><b><i>Максимальный сбой</i> (ntp.maxskew) -</b> максимальная ошибка смещения, связанная со сбоем локальных часов за время ntp.maxage, в секундах. Отношение ntp.maxskew к ntp.maxage интерпретируется как максимальный сбой, вызванный всей совокупностью факторов.</p>

<p align="justify"><b><i>Максимальное расстояние</i> (ntp.maxdistance) -</b> максимально допустимое расстояние между партнерами при синхронизации с использованием алгоритма отбора.</p>

<p align="justify"><b><i>Минимальный период рассылки</i> (ntp.minpoll) -</b> минимальный период рассылки, допустимый для любого из партнеров в сети Интернет. Этот период выражается в секундах и представляет собой степень 2.</p>

<p align="justify"><b><i>Максимальный период рассылки</i> (ntp.maxpoll) -</b>максимальный период рассылки, допустимый для любого из партнеров в сети Интернет. Этот период выражается в секундах и представляет собой степень 2.</p>

<p align="justify"><b><i>Минимум избранных часов</i> (ntp.minclock) - </b>минимальное число партнеров, необходимое для синхронизации (при использовании алгоритма отбора).</p>

<p align="justify"><b><i>Максимум избранных часов</i> (ntp.maxclock) -</b> максимальное число партнеров, необходимое для организации отбора (при использовании алгоритма селекции). </p>

<p align="justify"><b><i>Минимальная дисперсия</i> (ntp.mindisperse) -</b> минимальное значение приращения дисперсии для каждого из слоев в секундах (при использовании алгоритма фильтрации).</p>

<p align="justify"><b><i>Максимальная дисперсия</i> (ntp.maxdisperse) -</b> максимальная дисперсия в секундах с учетом потерянных данных (при использовании алгоритма фильтрации).</p>

<p align="justify"><b><i>Размер регистра доступности</i> (ntp.window) -</b> размер регистра доступности (peer.reach) в битах.</p>

<p align="justify"><b><i>Размер фильтра</i> (ntp.shift) -</b> размер сдвигового регистра фильтра часов (peer.filter) в каскадах.</p>

<p align="justify"><b><i>Вес фильтра</i> (ntp.filter) -</b> вес, используемый при вычислении дисперсии фильтра (применяется при работе с алгоритмом фильтрации).</p>

<p align="justify"><b><i>Выбранный вес</i> (ntp.select) -</b> вес, используемый при вычислении выбранной дисперсии (применяется при работе алгоритма селекции).</p>

<p align="justify"><b>Режимы работы</b></p>

<p align="justify">За исключением широковещательного режима, NTP-ассоциация формируется, когда два партнера обмениваются сообщениями и один или оба из них создает и поддерживает протокольную машину, называемую <b>ассоциацией</b>. Ассоциация может работать в одном из 5 режимов, заданных переменной peer.mode: <i>симметрично активный, симметрично пассивный, клиент, сервер и
широковещательный</i>:</p>

<p align="justify"><b><i>Симметрично активный</i> (1). </b>ЭВМ, работающая в этом режиме, периодически посылает сообщения вне зависимости от достижимости или слоя своего партнера. При работе в этом режиме ЭВМ оповещает о своем намерении синхронизовать и быть синхронизованной партнером.</p>

<p align="justify"><b><i>Симметрично пассивный</i></font> (2).</b> Этот тип ассоциации первоначально создается по прибытии сообщения от партнера, работающего в симметрично активном режиме. Он сохраняется, пока партнер достижим и функционирует в слое ниже или равном данной ЭВМ.
В противном случае ассоциация распадается. Однако ассоциация будет существовать до тех пор, пока, по крайней мере, одно сообщение не будет послано в качестве отклика. При работе в этом режиме ЭВМ оповещает о своем намерении синхронизовать и быть синхронизованной партнером.</p>

<p align="justify"><b><i>Клиент</i> (3).</b> ЭВМ, работающая в этом режиме, периодически посылает сообщения вне зависимости от достижимости или слоя своего партнера. При работе в этом режиме ЭВМ, обычно это сетевая рабочая станция, оповещает о своем намерении быть синхронизованной партнером.</p>

<p align="justify"><b><i>Сервер</i> (4).</b> Этот тип ассоциации первоначально создается по прибытии запроса клиента и существует только для отклика на этот запрос. После отклика ассоциация ликвидируется. При работе в этом режиме ЭВМ, обычно рабочая сетевая станция, оповещает о намерении синхронизовать партнера.</p>

<p align="justify"><b><i>Широковещательный</i> (5). </b>ЭВМ, работающая в этом режиме, периодически посылает сообщения вне зависимости от доступности или слоя партнеров. При работе в этом режиме ЭВМ, обычно сетевой сервер времени, который работает в широковещательной среде, оповещает о намерении синхронизовать всех партнеров.</p>

<p align="justify">ЭВМ, работающая в режиме клиента, иногда посылает NTP-сообщение ЭВМ, работающей в режиме сервера, например, сразу после перезагрузки и периодически после этого. Сервер откликается, меняя адреса и номера портов, занося необходимую информацию и отправляя сообщение назад клиенту. Серверы не должны хранить какую-либо статусную информацию в паузах между запросами
клиента, в то время как клиенты могут варьировать интервалы между NTP сообщениями, для того чтобы удовлетворить локальным требованиям. В этих режимах протокольная машина, описанная в этой статье, может быть существенно упрощена без заметной потери точности или надежности особенно при работе в
быстродействующей локальной сети.</p>

<p align="justify">В симметричных режимах отличие клиента от сервера практически исчезает. Симметрично пассивный режим предназначен для использования временными серверами, работающими вблизи базовых узлов (нижний слой) субсети синхронизации и со сравнительно большим числом
партнеров. В этом режиме идентификации партнера не требуется заранее, так как ассоциация с ее переменными состояния создана, только когда получено NTP-сообщение. Более того, запомненное состояние может быть использовано позднее, когда партнер станет недостижим или будет работать на более высоком уровне и по этой причине будет непригоден в качестве источника синхронизации.</p>

<p align="justify">Симметрично активный режим предназначен для использования серверами времени, работающими вблизи оконечных узлов (наивысший слой) синхронизации. Надежный временной сервис обычно может быть реализован с помощью двух партнеров на ближайшем нижележащем слое и одном партнере в том же слое. По этой причине поток сообщений обычно невелик, даже когда связь потеряна,
и на каждый запрос приходит отклик об ошибке.</p>

<p align="justify">В норме, один партнер работает в активном режиме (симметричный активный, клиент или широковещательный), как это сконфигурировано в стартовом файле, в то время как другие работают в пассивном режиме (симметричный пассивный или сервер), часто без предварительной конфигурации. Однако оба партнера могут быть сконфигурированы для работы в симметричном режиме. Условие ошибки возникает, когда оба партнера работают в одном и том же режиме, но не в симметричном активном. В таких случаях каждый партнер будет игнорировать сообщения, поступающие от другого, и ассоциация, если она существовала, будет ликвидирована из-за недостижимости партнера.</p>

<p align="justify">Широковещательный режим предназначен для работы в скоростных локальных сетях с большим числом рабочих станций, где не требуется высокая точность. При типичном сценарии один или более временных серверов LAN периодически посылают широковещательные сообщения рабочим станциям,
которые затем определяют время на основе предварительно заданной задержки распространения порядка нескольких миллисекунд.</p>

<p align="justify"><b>Обработка событий</b></p>

<p align="justify">Существенные события с точки зрения протокола NTP происходят при истечении времени таймеров партнера (peer.timer), один из которых ориентирован специально на данного партнера в активной ассоциации, а также при получении NTP-сообщения от различных партнеров. Событие может произойти как результат команды оператора или обнаруженной ошибки, такой как отказ
первичного эталона.</p>

<p align="justify"><b>Обозначения</b></p>

<p align="justify">Алгоритмы фильтрации и селекции NTP используют несколько переменных для хранения значений сдвига часов, RTT и дисперсии. Переменные, относящиеся к партнерам, обычно обозначаются строчными греческими буквами, а для первичного эталона времени используются прописные буквы. Эти
алгоритмы базируются на параметре, называемом <i>расстояние синхронизации</i>
(<font face="symbol">l</font>) и вычисляемом с использованием rtt и дисперсии.</p>

<p align="justify">Дисперсия партнера (<font face="symbol">e</font>) содержит вклады от ошибок измерения (<font face="symbol">r</font>) и накопления ошибок дрейфа (skew-error).</p>

<p align="justify">Каждый раз, когда соответствующие переменные партнеров изменяются, значения дисперсии корректируются. Ниже приводятся основные определения переменных и формулы их вычисления:</p>
<p align="justify"><font face="symbol">q</font> = peer.offset,<br>
<font face="symbol">d</font> = peer.delay,<br>
<font face="symbol">e</font> = peer.dispersion = <font face="symbol">r</font> +
<font face="symbol">jt</font> + <font face="symbol">e<sub>s</sub></font>,<br>
<font face="symbol">l</font> = <font face="symbol">e</font> + |<font face="symbol">d</font>|/2,</p>

<p align="justify"><font face="times new roman">где <font face="symbol">d</font> = rtt,
<font face="symbol">q</font> - сдвиг часов,
<font face="symbol">jt</font> - накопление сбоя, <font face="symbol">j</font> =
ntp.maxskew/ntp.maxage, <font face="symbol">t</font> - момент времени передачи исходной временной
метки (на основе <font face="symbol">t</font> вычисляется <font face="symbol">q</font> и
<font face="symbol">d</font>), <font face="symbol">e</font>
<font face="symbol"><sub>s</sub></font>
- дисперсия фильтра. Переменные, относящиеся к партнеру i, определяются следующим образом:</p>
<font face="symbol"><p>q</font> <sub>i</sub> = <font face="symbol">j</font> <sub>i</sub>, <br>
<font face="symbol">d</font> <sub>i</sub> = peer.rootdelay + <font face="symbol">d</font> <sub>i</sub>,<br>
<font face="symbol">e</font> <sub>i</sub> = peer.rootdispersion + <font face="symbol">e</font>
<sub>i</sub> + <font face="symbol">j</font> <font face="symbol">t</font><sub>i</sub>
(максимальная дисперсия часов партнера),<br>
<font face="symbol">l</font><sub>i</sub>= <font face="symbol">e</font><sub>i</sub> +
|<font face="symbol">d</font><sub>i</sub>|/2,</p>

<p align="justify">Окончательно, предполагая, что для синхронизации выбран i-ый партнер, система
переменных определяется следующим образом:</p>
<font face="symbol"><p>q</font> = комбинированное окончательное смещение (combined final offset),<br>
<font face="symbol">d</font> = <font face="symbol">d</font><sub>i</sub>,<br>
e = <font face="symbol">e</font><sub>i</sub> + <font face="symbol">e<sub>x</sub></font>  +
<font face="symbol">q</font>,<br>
<font face="symbol">l</font> = <font face="symbol">l</font><sub>i</sub>,</p>

<p align="justify">где <font face="symbol">e<sub>x</sub></font>  дисперсия выбора (select dispersion).</p>

<p align="justify">Приводимые ниже тексты программ, реализующие вычисления переменных, записаны на условном языке, напоминающем СИ.</p>

<p align="justify"><b>Процедура передачи</b></p>

<p align="justify">Процедура передачи запускается, когда таймер партнера станет равным нулю. В режиме клиента с широковещательным сервером сообщения вообще не посылаются. В режиме сервера сообщения посылаются только в качестве отклика на полученные запросы.</p>

<p align="justify">Нижеприведенный фрагмент программы инициализирует пакетный буфер и копирует пакетные переменные.</p>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="34%" valign="top"><p align="left">pkt.peeraddr <- peer.hostaddr;</td>
<td width="66%" valign="top"><p align="left">/* копирование системных и партнерских переменных */</td>
</tr>
</table>

pkt.peerport <- peer.hostport;<br>
pkt.hostaddr <- peer.peeraddr;<br>
pkt.hostport <- peer.peerport;<br>
pkt.leap <- sys.leap;<br>
pkt.version <- ntp.version;<br>
pkt.mode <- peer.mode;<br>
pkt.stratum <- sys.stratum;<br>
pkt.poll <- peer.hostpoll;<br>
pkt.precision <- sys.precision;<br>
pkt.rootdelay <- sys.rootdelay;<br>
if (sys.leap = 11<sub>2</sub> or (sys.clock - sys.reftime) > ntp.maxage)<br>
skew <- ntp.maxskew;<br>
else<br>
skew <- <font face="symbol">j</font> (sys.clock - sys.reftime);<br>
{pkt.rootdispersion <- sys.rootdispersion + (1 << sys.precision)} + skew;<br>
pkt.refid <- sys.refid;<br>
pkt.reftime <- sys.reftime;<br>

<p align="justify">Временная метка передачи pkt.xmt будет использована позднее, для того чтобы проконтролировать отклик. Таким образом, программа должна сохранить точное переданное значение. Кроме того, порядок копирования временных меток должен быть выбран так, чтобы не понизить
точность.</p>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="50%" valign="top"><p align="left">pkt.org <- peer.org;</td>
<td width="50%" valign="top"><p align="left">/* копирование временных меток */</td>
</tr>
</table>

pkt.rec <- peer.rec;<br>
pkt.xmt <- sys.clock;<br>
peer.xmt <- pkt.xmt;<br>

<p align="justify">Регистр доступности сдвигается на одну позицию влево, в освободившийся разряд записывается нуль. Если все биты регистра равны нулю, вызывается процедура очистки (clear procedure) для обнуления фильтра часов и выбора, если необходимо, нового источника синхронизации. Если ассоциация не была сконфигурирована при инициализации, то она ликвидируется.</p>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr>
<td width="46%" valign="top"><p align="left">peer.reach <- peer.reach <<1;</td>
<td width="46%" valign="top"><p align="left">/* актуализация доступности */</td>
</tr>
</table>

if (peer.reach = 0 and peer.config =0)<br>
begin<br>
ликвидируем ассоциацию;<br>
exit;<br>
endif<br>

<p align="justify">Если корректные данные введены в сдвиговый регистр фильтра хотя бы раз за время предыдущих двух периодов рассылки (младший бит peer.reach равен 1), счетчик корректных данных увеличивается на 1. После восьми таких удачных периодов интервал рассылки увеличивается. Процедура выбора часов вызывается, если необходимо заменить источник синхронизации.</p>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="50%" valign="top"><p align="left">if (peer.reach & 6 &#8800; 0)</td>
<td width="50%" valign="top"><p align="left">/* Проверка младших двух бит */</td>
</tr>
<tr><td width="50%" valign="top"><p align="left">if (peer.valid << ntp.shift)</td>
<td width="50%" valign="top"><p align="left">/* получены корректные данные */</td>
</tr>
</table>

peer.valid <- peer.valid + 1;<br>
else peer.hostpoll <- peer.hostpoll + 1;<br>
else begin<br>

<table  cellspacing=0 bordercolor="#000000" cellpadding=2 width=800>
<tr><td width="50%" valign="top"><p align="left">peer.valid <- peer.valid - 1;</td>
<td width="50%" valign="top"><p align="left">/* ничего не слышно */</td>
</tr>
</table>

peer.hostpoll <- peer.hostpoll - 1;<br>
call clock-filter(0, 0, ntp.maxdisperse);<br>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="50%" valign="top"><p align="left">call clock-select;</td>
<td width="50%" valign="top"><p align="left">/* выбираем источник синхронизации */</td>
</tr>
</table>

endif<br>
call poll-update;<br>
end transmit procedure;<br>

<p align="justify"><b> Процедура получения</b> </p>

<p align="justify">Процедура получения выполняется по приходу NTP-сообщения. Она проверяет сообщения, интерпретирует различные режимы и вызывает другие процедуры для фильтрации данных и выбора источника синхронизации. Если номер версии в пакете не соответствует текущей версии, сообщение может быть отброшено. Если получено управляющее сообщение NTP и код режима пакета равен
6 (управление), вызывается процедура управляющего сообщения. IP-адреса отправителя и адресата, а также номера портов устанавливаются соответствующими заданному партнеру. Если соответствия нет, производится новая инсталляция протокольной машины и формируется новая ассоциация.</p>

<p>begin receive procedure<br>
if (pkt.version &#8800; ntp.version>) exit;<br>
#ifdef (control messages implemented)<br>
if (pkt.mode = 6) call control-message;<br>
#endef<br>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="36%" valign="top"><p align="left">for (all associations)</td>
<td width="64%" valign="top"><p align="left">/* Здесь выполняется управление доступом */</td>
</tr>
</table>

match addresses and ports to associations;<br>
if (no matching association)<br>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="50%" valign="top"><p align="left">call receive-instantiation procedure;</td>
<td width="50%" valign="top"><p align="left">/* создаем ассоциацию */</td>
</tr>
</table></p>

<p align="justify">Вызов процедуры дешифровки осуществляется только в случае применения аутентификации.</p>
<p>#ifdef (authentication implemented)<br>
call decrypt;<br>
#endef</p>
<p align="justify">Если код режима пакета не равен нулю, он определяет режим на следующем этапе; в противном случае, режим определяется по номеру порта.</p>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="44%" valign="top"><p align="left">if (pkt.mode = 0)</td>
<td width="56%" valign="top"><p align="left">/* для совместимости со старыми версиями */</td>
</tr>
</table>

mode;<br>
else<br>
mode <- pkt.mode;<br>
case (mode, peer.hostmode)</p>

<p align="justify">В случае ошибки пакет просто игнорируется, а ассоциация, если она не была предварительно сконфигурирована, ликвидируется.</p>

<p>error: if (peer.config = 0) demobilize association;<br>
break;</p>

<p align="justify">В случае recv пакет обрабатывается, а ассоциация помечается как достижимая при условии 5-8 успешных проверок. Если и проверки с первой по 4-ую проходят успешно (данные корректны), вызывается процедура коррекции показания локальных часов. В противном случае, если ассоциация не была предварительно сконфигурирована, она ликвидируется.</p>

<table  cellspacing=0 bordercolor="#000000" cellpadding=2 width=800>
<tr><td width="29%" valign="top">
<p align="left">recv: call packet;</td>
<td width="71%" valign="top"><p align="left">/* обработать пакет */</td>
</tr>
<tr><td width="29%" valign="top"><p align="left">if (valid header) begin</td>
<td width="71%" valign="top"><p align="left">/* если правильный заголовок, актуализовать внутренние часы */</td>
</tr>
</table>

peer.reach <- peer.reach | 1;<br>
if (valid data) call clock-update;<br>
endif<br>
else<br>
if (peer.config = 0) ликвидировать ассоциацию;<br>
break;<br>

<p align="justify">В случае xmit, пакет обрабатывается и посылается промежуточный отклик. Ассоциация затем ликвидируется.</p>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="50%" valign="top"><p align="left">xmit: call packet;</td>
<td width="50%" valign="top"><p align="left">/* обработать пакет */</td>
</tr>
<tr><td width="50%" valign="top"><p align="left">peer.hostpoll <- peer.peerpoll;</td>
<td width="50%" valign="top"><p align="left">/* послать немедленно отклик */</td>
</tr>
</table>

call poll-update;<br>
call transmit;<br>
if (peer.config = 0) ликвидировать ассоциацию;<br>
break;<br>
<p align="justify">В случае pkt, пакет обрабатывается, а ассоциация помечается как достижимая при условии, что тесты 5-8 (правильный заголовок), перечисленные в пакетной процедуре, прошли успешно. Если, кроме того, прошли тесты 1-4 (корректные данные), вызывается процедура коррекции показаний локальных часов. В противном случае, если ассоциация не была предварительно
сконфигурирована, она сразу после отклика ликвидируется.</p>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="30%" valign="top"><p align="left">pkt: call packet;</td>
<td width="70%" valign="top"><p align="left">/* обработка пакета */</td>
</tr>
<tr><td width="30%" valign="top"><p align="left">if (valid header) begin</td>
<td width="70%" valign="top"><p align="left">/* если заголовок правилен, поправляется показание местных часов */</td>
</tr>
</table>

peer.reach <- peer.reach | 1;<br>
if (valid data) call clock-update;<br>
endif<br>
else if (peer.config = 0) begin<br>
<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="50%" valign="top"><p align="left">peer.hostpoll <- peer.peerpoll;</td>
<td width="50%" valign="top"><p align="left">/* послать немедленно отклик */</td>
</tr>
</table>

call poll-update;<br>
call transmit;<br>
ликвидировать ассоциацию;<br>
endif<br>
endcase<br>
end receive procedure;<br>
<p align="justify"><b> Пакетная процедура</b> </p>
<p align="justify">Пакетная процедура проверяет корректность сообщения, вычисляет задержку/смещение и вызывает другие процедуры для отбора данных и выбора источника синхронизации. Тест<b> 1</b> требует, чтобы переданная временная метка отличалась от последней, полученной от того же партнера. Тест<b> 2</b> требует, чтобы исходная временная метка соответствовала последней метке, посланной тому же партнеру. В случае широковещательного режима
(5) rtt=0 и полная точность операции передачи времени будет недостижимой. Однако, полученная точность может быть вполне приемлемой для многих целей. Процедура вызова коррекции времени использует в качестве параметра peer.hostpoll (peer.peerpoll может быть изменено).</p>

begin packet procedure<br>
<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="50%" valign="top"><p align="left">peer.rec <- sys.clock;</td>
<td width="50%" valign="top"><p align="left">/* забрать полученную временную метку */</td>
</tr>
</table>

if (pkt.mode &#8800; 5) begin<br>
<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="50%" valign="top"><p align="left">test1 <- (pkt.xmt &#8800; peer.org);</td>
<td width="50%" valign="top"><p align="left">/* Тест 1 */</font></td>
</tr>
<tr><td width="50%" valign="top"><p align="left">test2 <- (pkt.org = peer.xmt);</td>
<td width="50%" valign="top"><p align="left">/* Тест 2 */</td>
</tr>
</table>

endif<br>
else begin<br>
<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="50%" valign="top"><p align="left">pkt.org <- peer.rec;</td>
<td width="50%" valign="top"><p align="left">/* потеря временной метки из-за ошибки */</td>
</tr>
</table>

pkt.rec <- pkt.xmt;<br>
<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="50%" valign="top"><p align="justify">test1;</td>
<td width="50%" valign="top"><p align="left">/* ложные тесты */</font></td>
</tr>
</table>

test2;<br>
endif<br>
<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="50%" valign="top"><p align="left">peer.org <- pkt.xmt;</td>
<td width="50%" valign="top"><p align="left">/* актуализация исходной временной метки */</td>
</tr>
<tr><td width="50%" valign="top"><p align="left">peer.peerpoll <- pkt.poll;</td>
<td width="50%" valign="top"><p align="left">/* скорректировать период рассылки */</td>
</tr>
</table>

call poll-update(peer.hostpoll);<br>

<p align="justify"><b> Тест 3</b> требует, чтобы исходная и полученная временные метки не были равны нулю. Если любая из них равна нулю, ассоциация не синхронизирована или потеряла доступ в одном или обоих направлениях.</p>

<p align="justify">test3 <- (pkt.org &#8800; 0 and pkt.rec &#8800; 0); /* Тест 3 */</p>

<p align="justify">rtt и временное смещение по отношению партнера вычисляется следующим образом. Пусть i четное целое число. <br>
Тогда t<sub>i-3</sub>, t<sub>i-2</sub>, t<sub>i-1</sub> и t<sub>i</sub> - содержимое переменных
pkt.org, pkt.rec, pkt.xmt и peer.rec, соответственно. Смещение часов <font face="symbol">j</font>,
rtt=<font face="symbol">d</font><font face="times new roman"> и дисперсия
<font face="symbol">e</font> ЭВМ по отношению к партнеру равны:</p>

<p><font face="symbol">d</font> = (t<sub>i</sub> - t<sub>i-3</sub>) - (t<sub>i-1</sub> - t<sub>i - 2</sub>),<br>
<font face="symbol">j</font> = ((t<sub>i - 2</sub> - t<sub>i-3</sub>) + ( t<sub>i-1</sub> - t<sub>i</sub>))/2,<br>
<font face="symbol">e</font> = (1 << sys.precision) + <font face="symbol">j</font> (t<sub>i</sub> - t<sub>i-3</sub>),</p>

<p align="justify">где, как и прежде, <font face="symbol">j</font> = ntp.maxskew/ntp.maxage. << - обозначает сдвиг кода влево. Значение <font face="symbol">e</font> представляет собой максимальную ошибку или дисперсию, связанную с ошибкой измерения на стороне ЭВМ, а также накопление ошибок из-за дрейфа локальных часов за время после посылки последнего сообщения,
посланного партнером. Дисперсия корректируется процедурой фильтра часов (clock-filter).</p>

<p align="justify">Рассмотренный метод эквивалентен непрерывному стробированию, которое используется в некоторых телефонных сетях [bel86]. Преимуществом метода является полная независимость от порядка и времени прихода сообщений, а также допустимость потери некоторых пакетов. Очевидно, что достижимые точности зависят от статистических свойств каналов связи.</p>

<p align="justify"><b>Тест 4</b> требует, чтобы вычисленная задержка лежала в допустимых пределах:</p>

<p align="justify">test4 <- (|<font face="symbol">d</font>| < ntp.maxdisperse И
<font face="symbol">e</font> <ntp.maxdisperse);  /* Тест 4 */</p>

<p align="justify"><b>Тест 5</b> используется, только если реализован механизм аутентификации. Он требует, чтобы либо аутентификация была явно блокирована, либо чтобы аутентификатор в точности соответствовал тому, что описано в процедуре дешифровки.</p>

<p>#ifdef (authentication implemented)  /* Тест 5 */<br>
test5 <- ((peer.config = 1 и peer.authenable = 0) или peer.authentic = 1);<br>
#endef</p>

<p align="justify"><b> Тест 6</b> требует, чтобы часы партнера были синхронизованы, и время с момента последней коррекции было положительным и меньше чем ntp.maxage.</p>

<p align="justify"><b>Тест 7</b> гарантирует, что ЭВМ не будет синхронизовано от партнера с большим кодом номера слоя. </p>

<p align="justify"><b>Тест 8</b> требует, чтобы заголовок содержал соответствующие коды в полях pkt.rootdelay и pkt.rootdispersion.</p>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="66%" valign="top"><p align="left">test6 <- (pkt.leap &#8800; 11<sub>2</sub> and</td>
<td width="34%" valign="top"><p align="left">/* Тест 6 */</td>
</tr>
</table>

{pkt.reftime &#8804; pkt.xmt << pkt.reftime + ntp.maxage})<br>
<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="66%" valign="top"><p align="justify">test7 <- {pkt.stratum &#8804; sys.stratum} and</td>
<td width="34%" valign="top"><p align="justify">/* Тест 7 */</td>
</tr>
</table>

{pkt.stratum << ntp.maxstratum};<br>
<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="66%" valign="top"><p>test8 <- (| pkt.rootdelay | << ntp.maxdisperse and</td>
<td width="34%" valign="top"><p align="justify">/* Тест 8 */</td>
</tr>
</table>

{pkt.rootdispersion << ntp.maxdisperse});<br>

<p align="justify">С точки зрения последующей обработки пакеты содержат корректные данные, если успешно проходят тесты 1-4 (test1 & test2 & test3 & test4 = 1), вне зависимости от результатов других тестов. Только пакеты с корректными данными могут использоваться для вычисления смещения (offset), задержки (delay) и дисперсии. Пакеты имеют корректные заголовки, если успешно
проходят тесты 5-8 (test5 & test6 & test7 & test8 = 1), вне зависимости от результатов остальных тестов. Только пакеты с корректными заголовками могут использоваться для определения того, может ли партнер быть выбран в качестве источника синхронизации. Заметим, что тесты 1-2 не используются в широковещательном режиме.</p>

<p align="justify">Процедура "часовой фильтр" вызывается для вычисления задержки (peer.delay), смещения (peer.offset) и дисперсии (peer.dispersion) для партнера. Спецификация алгоритма часового фильтра не является составной частью протокола NTP. По этой причине описания, приводимые ниже, следует рассматривать как рекомендательные.</p>
if (not valid header) exit;<br>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="52%" valign="top"><p align="left">peer.leap < pkt.leap;</td>
<td width="48%" valign="top"><p align="left">/* Копирование переменных пакета */</td>
</tr>
</table>

peer.stratum <- pkt.stratum>;<br>
peer.precision <- pkt.precision>;<br>
peer.rootdelay <- pkt.rootdelay>;<br>
peer.rootdispersion <- pkt.rootdispersion>;<br>
peer.refid <- pkt.refid>;<br>
peer.reftime <- pkt.reftime>;<br>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="59%" valign="top">
<p align="left">if (valid data) call clock-filter(<font face="symbol">q</font>, <font face="symbol">d</font>, <font face="symbol">e</font>);</td>
<td width="41%" valign="top"><p align="left">/* обработка данных */</td>
</tr>
</table>

end packet procedure;<br>

<p align="justify"><b> Процедура коррекции показаний часов</b> </p>

<p align="justify">Процедура коррекции показания часов вызывается процедурой приема, когда процедура фильтрации определила корректные значения смещения задержки и дисперсии для данного партнера.</p>

begin clock-update procedure<br>
<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="50%" valign="top"><p align="left">call clock-select;</td>
<td width="50%" valign="top"><p align="left">/* Выбор базовых часов */</td>
</tr>
</table>

if (sys.peer &#8800; peer) exit;<br>

<p align="justify">Может так случиться, что локальные часы оказались сброшены. В этом случае вызывается процедура очистки (clear procedure) для каждого из партнеров, чтобы возвратить в исходное состояние фильтр часов, период рассылки и, если необходимо, осуществить выбор нового источника синхронизации.</p>

<p align="justify">Процедура расстояния вычисляет базовую (root) задержку
<font face="symbol">d</font>, базовую дисперсию <font face="symbol">e</font> и базовое расстояние синхронизации <font face="symbol">l</font>. ЭВМ не будет
синхронизовать выбранного партнера, если расстояние больше чем ntp.maxdistance.</p>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="50%" valign="top"><p align="left"><font face="symbol">l</font> andistance(peer);</td>
<td width="50%" valign="top"><p align="left">/* обновление системных переменных */</td>
</tr>
</table>

if (<font face="symbol">l</font> &#8805; ntp.maxdistance) exit;<br>
sys.leap <- peer.leap;<br>
sys.stratum <- peer.stratum + 1;<br>
sys.refid <- peer.peeraddr;<br>
call local-clock;<br>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="42%" valign="top"><p align="left">if (local clock reset) begin</td>
<td width="58%" valign="top"><p align="left">/* если сброс, очистить системные переменные */</td>
</tr>
</table>

sys.leap <- 11<sub>2</sub>;<br>
for (all peers) call clear;<br>
endif<br>
else begin<br>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="42%" valign="top"><p align="left">sys.peer <- peer;</td>
<td width="58%" valign="top"><p align="left">/* если нет, то подстроить локальные часы */</td>
</tr>
</table>

sys.rootdelay <- <font face="symbol">d</font>;<br>
sys.rootdispersion <- <font face="symbol">e</font> + max (<font face="symbol">e<sub>x</sub>
</font>  + |<font face="symbol">t</font>|, ntp.mindisperse);<br>
endif<br>
sys.reftime <- sys.clock;<br>
end clock-update procedure;<br>

<p align="justify">В некоторых конфигурациях системы прецизионный источник временной информации доступен в виде последовательности синхронизующих импульсов, следующих с периодом в одну секунду. Обычно это является дополнением к базовому источнику времязадающей информации, такому как радио-часы или даже сам протокол NTP, для того чтобы обеспечить подсчет секунд, минут, часов и
дней. В этих конфигурациях системные переменные устанавливаются с учетом источника, от которого поступают такие импульсы. Для конфигураций, которые поддерживают первичные эталонные источники, такие как радио-часы или калиброванные атомные часы код слоя устанавливается равным 1, поскольку
именно он является действительным источником синхронизации.</p>

<p align="justify">Спецификация алгоритмов выбора часов и работы локальных часов не являются составной частью NTP. По этой причине описания этих алгоритмов, представленные ниже, следует рассматривать лишь как рекомендации.</p>

<p align="justify"><b>Работа первичных часов (primary-clock procedure)</b></p>

<p align="justify">Когда ЭВМ связана с первичным эталоном времени, таким как радио-часы, удобно ввести информацию об этих часах в базу данных, как если бы это был обычный партнер. В процедуре первичных часов часы запрашиваются раз в минуту или около того, полученный же временной код используется для корректировки показаний местных часов. Когда обнуляется peer.timer для первичного партнера, процедура передачи не вызывается, а посылается запрос радио-часам с использованием ASCII-последовательности, предусмотренной для этого случая. Когда получен корректный временной код от радио-часов, он преобразуется в формат временной метки NTP и корректируются соответствующие
переменные партнера. Величина peer.leap устанавливается в зависимости от состояния бита оповещения временного кода, если таковой имеется, или вручную оператором. Значение для peer.peeraddr, которое становится равно sys.refid, когда вызывается процедура корректировки показаний часов, делается
равным ASCII-строке, описывающей часы.</p>

begin primary-clock-update procedure<br>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="50%" valign="top"><p align="left">peer.leap <- "from" radio or operator;</td>
<td width="50%" valign="top"><p align="left">/* Копирование переменных */</td>
</tr>
</table>

peer.peeraddr <- ascii identifier;<br>
peer.rec <- radio timestamp;<br>
peer.reach <- 1;<br>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="66%" valign="top" colspan=2><p align="left">call clock-filter({sys.clock -
     peer.rec, 0, 1 << peer.precision});</td>
<td width="34%" valign="top"><p align="left">/* образец процесса */</td>
</tr>
<tr><td width="66%" valign="top"><p align="left">call clockupdate;</td>
<td width="34%" valign="top" colspan=2><p align="left"> /* коррекция локальных часов */</td>
</tr>
</table>

end primary-clock-update procedure;<br>

<p align="justify"><b> Процедуры инициализации</b> </p>

<p align="justify">Процедура инициализации вызывается при перезагрузке системы или при повторном запуске демона NTP. Состояние локальных часов при загрузке предполагается неопределенным; однако, некоторые виды оборудования обеспечивают доступ к локальным часам, как в ходе загрузки, так и сразу после нее. Переменная точности определяется внутренней архитектурой оборудования локальных
часов. Аутентификационные переменные используются лишь при реализации механизма аутентификации. Значения этих переменных определяются процедурами, выходящими за рамки протокола NTP.</p>

begin initialization procedure<br>
#ifdef (authentication implemented)<br>
sys.keys <- as required;<br>
#endef;<br>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="50%" valign="top"><p align="justify">sys.leap <- 11<sub>2</sub>;</td>
<td width="50%" valign="top"><p align="justify">/* копирование переменных */</td>
</tr>
</table>

sys.stratum <- 0 (undefined);<br>
sys.precision <- host~precision;<br>
sys.rootdelay <- 0(undefined);<br>
sys.rootdispersion <- 0 (undefined);<br>
sys.refid <- 0 (undefined);<br>
sys.reftime <- 0 (undefined);<br>
sys.clock <- external reference;<br>
sys.peer <-  null;<br>
sys.poll <- ntp.minpoll;<br>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="43%" valign="top"><p align="left">for (all configured peers)</td>
<td width="57%" valign="top"><p align="left">/* создание конфигурированных ассоциаций */</td>
</tr>
</table>

call initialization-instantiation procedure;<br>
end initialization procedure;<br>

<p align="justify"><b>Процедура</b> initialization-instantiation</p>

<p align="justify">Эта процедура является аппаратно-зависимой и служит, среди прочего, для формирования ассоциации. Адреса и режимы работы партнеров определяются в процессе чтения при перезагрузке или в результате обработки команд оператора. В случае привлечения механизма аутентификации только аутентифицированный партнер может стать источником синхронизации.</p>

begin initialization-instantiation procedure<br>
peer.config <- 1;<br>
#ifdef (authentication implemented)<br>
peer.authenable <- 1 (suggested);<br>
peer.authentic <- 0;<br>
peer.hostkeyid <- as required;<br>
peer.peerkeyid <- 0;<br>
#endef;<br>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="50%" valign="top"><p align="left">peer.peeraddr <- peer ip address;</td>
<td width="50%" valign="top"><p align="left">/* копирование переменных */</td>
</tr>
</table>

peer.peerport <- ntp.port;<br>
peer.hostaddr <- host ip address;<br>
peer.hostport <- ntp.port;<br>
peer.mode <- host mode;<br>
peer.peerpoll <- 0 (undefined);<br>
peer.timer <- 0;<br>
peer.delay <- 0 (undefined);<br>
peer.offset <- 0 (undefined);<br>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="50%" valign="top"><p align="left">call clear;</td>
<td width="50%" valign="top"><p align="left">/* инициализация ассоциации */</td>
</tr>
</table>

end initialization-instantiation procedure;<br>

<p align="justify"><b>Процедура receive-instantiation</b> </p>

<p align="justify">Процедура receive-instantiation вызывается процедурой приема, когда обнаруживается новый партнер. Она инициализирует переменные партнера и формирует ассоциацию. Если сообщение получено от партнера, работающего в режиме клиента (3), ЭВМ переводится в режим сервера
(4); в противном случае, она устанавливается в симметрично пассивный режим (2).</p>

begin receive-instantiation procedure<br>
#ifdef (authentication implemented)<br>
peer.authenable <- 0;<br>
peer.authentic <- 0;<br>
peer.hostkeyid <- as required;<br>
peer.peerkeyid <- 0;<br>
#endef<br>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="50%" valign="top"><p align="left">peer.config <- 0;</td>
<td width="50%" valign="top"><p align="left">/* Копирование переменных */</td>
</tr>
</table>

peer.peeraddr <- pkt.peeraddr;<br>
peer.peerport <- pkt.peerport;<br>
peer.hostaddr <- pkt.hostaddr;<br>
peer.hostport <- pkt.hostport;<br>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="50%" valign="top"><p align="left">if (pkt.mode = 3)</td>
<td width="50%" valign="top"><p align="left">/* Определение режима */</td>
</tr>
</table>

peer.mode <- 4;<br>
else<br>
peer.mode <- 2;<br>
peer.peerpoll <- 0 (undefined);<br>
peer.timer <- 0;<br>
peer.delay <- 0 (undefined);<br>
peer.offset <- 0 (undefined);<br>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="50%" valign="top"><p align="left">call clear;</td>
<td width="50%" valign="top"><p align="left">/* инициализация ассоциации */</td>
</tr>
</table>

end receive-instantiation procedure;<br>

<p align="justify"><b> Процедура primary clock-instantiation </b> </p>

<p align="justify">Эта процедура вызывается из процедуры инициализации для того, чтобы установить переменные состояния для первичных часов. Значение peer.precision определяется из спецификации радио-часов и аппаратного интерфейса. Значение peer.rootdispersion номинально равно удесятеренной
максимальной ошибке радио-часов, например, 10 мсек для WWVB или радио-часов goes и 100 мсек для менее точных радио-часов WWV.</p>

begin clock-instantiation procedure<br>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="50%" valign="top"><p align="left">peer.config <- 1;</td>
<td width="50%" valign="top"><p align="left">/* копирование переменных */</td>
</tr>
</table>

peer.peeraddr <- 0 undefined;<br>
peer.peerport <- 0 (not used);<br>
peer.hostaddr <- 0 (not used);<br>
peer.hostport <- 0 (not used);<br>
peer.leap <- 11<sub>2</sub>;<br>
peer.mode <- 0 (not used);<br>
peer.stratum <- 0;<br>
peer.peerpoll <- 0 (undefined);<br>
peer.precision <- clock precision;<br>
peer.rootdelay <- 0;<br>
peer.rootdispersion <- clock dispersion;<br>
peer.refid <- 0 (not used);<br>
peer.reftime <- 0 (undefined);<br>
peer.timer <- 0;<br>
peer.delay <- 0 (undefined);<br>
peer.offset <- 0 (undefined);<br>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="50%" valign="top"><p align="left">call clear;</td>
<td width="50%" valign="top"><p align="left">/* инициализация ассоциации */</td>
</tr>
</table>

end clock-instantiation procedure;<br>

<p align="justify">В некоторых конфигурациях, включающих в себя атомные часы или приемники LORAN-C, первичный эталон может выдавать только секундные импульсы и не предоставлять полного временного кода (числа секунд и пр.). В этих конфигурациях нумерация секунд может быть получена из других источников, таких как радио-часы или даже другие NTP-партнеры. В этих конфигурациях
переменные первичных часов должны отражать особенности первичного эталона, а не источника нумерации секунд. Однако если источник нумерации секунд отказал или работает некорректно, актуализация локальных часов от первичного эталона должна быть заблокирована.</p>

<p align="justify"><b>Процедура очистки</b></p>

<p align="justify">Процедура очистки вызывается, когда произошло событие, которое значительно изменило достижимость или вызвало поломку локальных часов.</p>
begin clear procedure<br>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="39%" valign="top"><p align="left">peer.org <- 0 (undefined);</td>
<td width="61%" valign="top"><p align="left">/* пометка неопределенных временных меток */</td>
</tr>
</table>

peer.rec <- 0 (undefined);<br>
peer.xmt <- 0 (undefined);<br>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="45%" valign="top"><p align="left">peer.reach <- 0;</td>
<td width="55%" valign="top" colspan=2><p align="left">/* сброс переменных состояния */</td>
</tr>
<tr><td width="45%" valign="top" colspan=2><p>peer.filter <- [0, ,0, ntp.maxdisperse];</td>
<td width="55%" valign="top"><p align="left">/* все ступени */</td>
</tr>
</table>

peer.valid <- 0;<br>
peer.dispersion <- ntp.maxdisperse;<br>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="45%" valign="top"><p align="left">{peer.hostpoll <- ntp.minpoll};</td>
<td width="55%" valign="top"><p align="left">/* первичная установка периода рассылки */</td>
</tr>
</table>

call poll-update;<br>
<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="45%" valign="top"><p align="left">call clock-select;</td>
<td width="55%" valign="top"><p align="left">/* Выбор эталонных часов */</td>
</tr>
</table>

end clear procedure;<br>

<p align="justify"><b>Процедура запроса-коррекции (poll-update)</b></p>

<p align="justify">Процедура запросов-коррекции вызывается, когда происходит событие, которое может вызвать изменение периода запросов (рассылки) или таймера партнера. Она проверяет значения периода запросов ЭВМ (peer.hostpoll) и партнера (peer.peerpoll), а также устанавливает их в заданных пределах.</p>

begin poll-update procedure<br>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="50%" valign="top"><p align="left">temp <-  peer.hostpoll;</td>
<td width="50%" valign="top"><p align="left">/* определение периода запросов ЭВМ */</td>
</tr>
</table>

if (peer = sys.peer)<br>
temp <- min (temp, {sys.poll, ntp.maxpoll)};<br>
else<br>
temp <- min (temp, ntp.maxpoll);<br>
peer.hostpoll <- max (temp, ntp.minpoll);<br>
temp <- 1 <<min ({peer.hostpoll, max (peer.peerpoll, ntp.minpoll)});<br>

<p align="justify">Если интервал запросов (рассылок) не изменился, а таймер партнера на нуле, то таймер просто сбрасывается в начальное состояние. Если интервал запросов изменен, и новое значение таймера больше текущего значения, никаких дополнительных действий не требуется; в противном случае величина выдержки таймера партнера должна быть уменьшена. Когда время выдержки
таймера партнера уменьшается, важно исключить тенденцию синхронизации обмена между партнерами. Благоразумной предосторожностью является рэндмизация первой передачи после уменьшения выдержки таймера.</p>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="50%" valign="top"><p align="left">if (peer.timer = 0)</td>
<td width="50%" valign="top"><p align="left">/* сброс таймера партнера */</td>
</tr>
</table>

peer.timer <- temp;<br>
else if (peer.timer >temp)<br>
peer.timer <- (sys.clock & (temp - 1)) + 1;<br>
end poll-update procedure;<br>

<p align="justify"><b>Процедура расстояния синхронизации (synchronization distance)</b></p>

<p align="justify">Процедура расстояния вычисляет расстояние синхронизации на основе переменных партнеров.</p>

<p>begin distance(peer) procedure;<br>
<font face="symbol">d</font>  <- {peer.rootdelay + |peer.delay|};<br>
<font face="symbol">e</font>  <- {peer.rootdispersion + peer.dispersion + <font face="symbol">f</font> (sys.clock - peer.update)};<br>
<font face="symbol">l</font><-<font face="symbol">e</font> + |<font face="symbol">d</font>|/2;<br>
end distance procedure;</p>

<p align="justify">Заметим, что, в то время как <font face="symbol">d</font>  может быть в некоторых случаях отрицательной, <font face="symbol">e</font>  и <font face="symbol">l</font> всегда положительны.</p>

<p align="justify"><b>Замечания о контроле доступа</b></p>

<p align="justify">Конструкция NTP устроена так, что случайная или намеренная модификация данных временного сервера не должна привести к серьезным ошибкам синхронизации. Однако успех этого подхода зависит от дополнительных временных серверов и альтернативных сетевых маршрутов, а также от предположения, что искажения не охватывают большинство временных серверов одновременно.
В принципе уязвимость субсети может быть улучшена разумным выбором временных серверов. Механизм аутентификации также позволяет повысить надежность синхронизации. Следует, правда, принимать во внимание, что шифрование/дешифрование данных заметно ухудшает точность синхронизации.</p>

<p align="justify">Если требуется более надежная модель, система может базироваться на списке доступа, в который включаются 32-битовый IP-адрес, 32-битовая маска и 3-битовый код режима работы. Если логическое <B>И</B> адреса эталона (pkt.peeraddr) и маски на входе ЭВМ соответствуют соответствующим
адресу и режиму (pkt.mode), доступ разрешается, в противном случае отправителю запроса присылается ICMP-сообщение об ошибке. Список управления доступом служит фильтром, определяющим, какой из партнеров может сформировать ассоциацию.</p>

<p align="justify"><b>Алгоритмы фильтрации и селекции</b></p>

<p align="justify">Наиболее важным фактором, влияющим на точность и надежность синхронизации, является набор алгоритмов, используемых для уменьшения статистических ошибок и искажений при сбоях в различных компонентах субсети. Алгоритмы, описанные в этой статье, не являются частью стандарта NTP, по этой причине допускается использование любых других алгоритмов.</p>

<p align="justify">Для того чтобы NTP алгоритмы фильтрации и отбора работали эффективно, полезно иметь меру вариации для каждого из партнеров. Принятая мера вариации базируется на разностях первого порядка, которые легко вычислить. Существует две меры, одна называемая дисперсией фильтра
<font face="symbol">e<sub>s</sub></font>, и другая дисперсия выбора (select dispersion) <font face="symbol">e<sub>z</sub></font>. Обе меры вычисляются как взвешенные суммы смещений из списка, сформированного на основе расстояний синхронизации. Если <font face="symbol">q</font><sub>i</sub> (0<font face="symbol">Ј</font> i < n) смещение i-ой записи, тогда разность <font face="symbol">e</font><sub>ij</sub> i-ой записи по отношению к j-ой
записи определяется как |<font face="symbol">q</font><sub>i</sub> - <font face="symbol">q</font> <sub>j</sub>|. Дисперсия относительно j-ой записи определяется как <font face="symbol">e</font><sub>j</sub> =

<sub><sub><img src="image1067.gif" tppabs="http://book.itep.ru/4/44/image1067.gif"></sub></sub>,

где w - весовой коэффициент, который служит для учета влияния расстояния синхронизации на дисперсию. В алгоритмах NTP w выбирается меньше 1/2: w = ntp.filter для дисперсии фильтра (filter dispersion) и w = NTP.SELECT для дисперсии выбора (select dispersion). <br>
Дисперсия <font face="symbol">e<sub>s</sub></font> и <font face="symbol">e<sub>x</sub></font> определены относительно 0-ой записи <font face="symbol">e</font><sub>0</sub>.</p>

<p align="justify">Существует две процедуры, описанные ниже, процедура "часовой-фильтр" (clock-filter), которая используется для выбора лучших записей смещения для данных часов, и процедура "выбора часов" (clock-selection), которая используется, чтобы выбрать наилучшие часы среди иерархического набора часов.</p>

<p align="justify"><b>Процедура часовой фильтр (clock-filter)</b> </p>

<p align="justify">Процедура часовой фильтр исполняется по прибытии сообщения NTP или другого события, в результате которого получены новые данные. Она использует аргументы (<font face="symbol">q</font>, <font face="symbol">d</font>, <font face="symbol">e</font>), где <font face="symbol">q</font> - результат измерения смещения часов, содержащийся в
записи, а <font face="symbol">d</font> и <font face="symbol">e</font> соответственно RTT и дисперсия. Процедура определяет значение отфильтрованного смещения часов (filtered clock offset - peer.offset), RTT (peer.delay) и дисперсии (peer.dispersion). Она также корректирует дисперсию хранящихся записей и текущее показание часов (peer.update).</p>

<p align="justify">Процедура часового фильтра использует сдвиговый регистр (peer.filter), который состоит из NTP.SHIFT каскадов, каждый каскад содержит значения <font face="symbol">q</font><sub>i</sub>, <font face="symbol">d</font><sub>i</sub> и <font face="symbol">e</font> <sub>i</sub>, которые пронумерованы, начиная с нуля, слева направо. Фильтр инициализируется процедурой очистки при этом заносятся значения [0, 0, NTP.MAXDISPERSE] во
всех каскадах. Новые данные записей вдвигаются в фильтр с левого конца. Пакетная процедура выдает записи в формате (<font face="symbol">q</font> ,<font face="symbol">d</font>, <font face="symbol">e</font>), когда приходят новые корректирующие данные, в то время как процедура передачи выдает записи в форме [0, 0, NTP.MAXDISPERSE], когда истекает два периода запроса без поступления свежих данных. Когда одни и те же символы (<font face="symbol">q</font>,
<font face="symbol">d</font>, <font face="symbol">e</font>) используютсядля аргументов, содержимого часового фильтра и переменных партнера, их значения обычно понятно из контекста. Ниже представлена псевдопрограмма, поясняющая работу данной процедуры.</p>

<p align="justify">begin clock-filter procedure (<font face="symbol">q</font>,
<font face="symbol">d</font>, <font face="symbol">e</font>)</p>

<p align="justify">Дисперсия <font face="symbol">e</font><sub>i</sub> для всех корректных записей в регистре фильтра должна корректироваться с тем, чтобы отражать накопление смещения со времени последней коррекции. Эти записи заносятся также во временный список, следуя стандартному формату записей [расстояние, индекс]. Записи в регистре сдвигаются вправо, новые записи вводятся слева, а самая правая запись теряется. Временный список сортируется по значению расстояния. Если в списке не остается записей, процедура прерывается без корректировки переменных партнера.</p>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="50%" valign="top"><p align="left">for (i from ntp.size 1 to 1) begin</td>
<td width="50%" valign="top"><p align="left">/* коррекция дисперсии */</td>
</tr>
</table>

[<font face="symbol">q</font><sub>i</sub>, <font face="symbol">d</font><sub>i</sub>,
<font face="symbol">e</font><sub>i</sub>] <- [<font face="symbol">q</font><sub>{i-1}</sub>,
<font face="symbol">d</font><sub>{i-1}</sub>, <font face="symbol">e</font><sub>{i-1}</sub>];<br>
/* shift stage right */<br>
<font face="symbol">e</font><sub>i</sub> = <font face="symbol">e</font><sub>i</sub> +
<font face="symbol">ft</font>;<br>
add [<font face="symbol">l</font><sub>i</sub> &#8801; <font face="symbol">e</font><sub>i</sub> +
{|<font face="symbol">d</font><sub>i</sub>|}/2, i] to temporary list;<br>
endfor;<br>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="66%" valign="top">
<p align="left">[<font face="symbol">q</font><sub>0</sub>, <font face="symbol">d</font><sub>0</sub>,
<font face="symbol">e</font><sub>0</sub>] <- [<font face="symbol">q</font>,
<font face="symbol">d</font>, <font face="symbol">e</font>];</td>
<td width="34%" valign="top"><p align="left">/* ввести новую запись */</td>
</tr>
</table>

add [<font face="symbol">l</font> &#8801; <font face="symbol">e</font> + {|<font face="symbol">d</font>|}/2, 0] to temporary list;<br>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="55%" valign="top">
<p align="justify">peer.update <- sys.clock;</td>
<td width="45%" valign="top"><p align="justify">/* сбросить показание часов */</td>
</tr>
</table>

sort temporary list by increasing [distance ||index];<br>
<p align="justify">где [distance ||index] представляет собой объединение полей расстояния и индекса (расстояние занимает старшую позицию). Дисперсия фильтра
<font face="symbol">e<sub>s</sub></font> вычисляется и включается в дисперсию партнера. Заметим, что временный список для этой цели уже упорядочен.</p>
<font face="symbol">e<sub>s</sub></font>  <- 0;<br>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="50%" valign="top"><p align="left">for (i from ntp.shift-1 to 0)</td>
<td width="50%" valign="top"><p align="left">/* вычисление дисперсии фильтра */</td>
</tr>
</table>

if (peer.dispersion<sub>index[i]</sub> &#8805; NTP.MAXDISPERSE or
|<font face="symbol">q</font><sub>i</sub>
- <font face="symbol">q</font><sub>0</sub> > NTP.MAXDISPERSE)<br>
<font face="symbol">e<sub>s</sub></font> <- (<font face="symbol">e<sub>s</sub></font> +
NTP.MAXDISPERSE) * NTP.FILTER;<br>
else<br>
<font face="symbol">e<sub>s</sub></font> <- (<font face="symbol">e<sub>s</sub></font> +
|<font face="symbol">q</font><sub>i</sub>
- <font face="symbol">q</font><sub>0</sub>|) * NTP.FILTER;<br>

<p align="justify">Смещение партнера <font face="symbol">q</font><sub>0</sub>, задержка <font face="symbol">d</font><sub>0</sub> и дисперсия <font face="symbol">e</font><sub>0</sub> выбираются как величины, соответствующие записи с минимальным расстоянием; другими словами, записи, соответствующей первому элементу временного списка (в данной нотации имеет индекс 0).</p>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="50%" valign="top">
<p align="left">peer.offset <- <font face="symbol">q</font><sub>0</sub>;</td>
<td width="50%" valign="top"><p align="left">/* корректировка переменных партнера */</td>
</tr>
</table>

peer.delay <- <font face="symbol">d</font><sub>0</sub>;<br>
peer.dispersion <- min(<font face="symbol">e</font><sub>0</sub> +
<font face="symbol">e<sub>s</sub></font>, NTP.MAXDISPERSE);<br>
end clock-filter procedure<br>

<p align="justify">Переменные peer.offset и peer.delay представляют смещение шкалы часов и RTT для локальных часов, измеренные относительно часов партнера. Обе они усредняются по большому числу измерений в течение длительного периода времени. Переменная peer.dispersion характеризует максимальную ошибку из-за неточности измерений, дрейфа и вариации записей. Все три переменные
используются при выборе часов для синхронизации.</p>

<p align="justify"><b>Процедура выбора часов</b> </p>

<p align="justify">Процедура выбора часов использует переменные партнера <font face="symbol">q</font>, <font face="symbol">d</font>, <font face="symbol">e</font> и <font face="symbol">t</font>, она вызывается, когда эти переменные изменились или изменился статус доступности. Процедура включает в себя две составные части: алгоритм пересечения (intersection algorithm) и
алгоритм кластеризации (clustering algorithm). Алгоритм пересечения подготавливает список кандидатов партнеров, могущих стать источниками синхронизации и вычисляет доверительный интервал для каждого из них. Алгоритм кластеризации сортирует список кандидатов по кодам слоя и расстояния
синхронизации. Системная переменная sys.peer представляет собой указатель на наиболее вероятного кандидата, если таковой имеется, или на нулевую величину в противном случае.</p>

<p align="justify"><b>Алгоритм пересечения</b> </p>

<p align="justify">begin clock-selection procedure</p>

<p align="justify">Каждый из партнеров просматривается последовательно и добавляется в конец списка, если он прошел ряд тестов. Для каждого из m кандидатов в список заносятся 3 записи в форме [указатель, тип]: [<font face="symbol">q</font> - <font face="symbol">l</font>, - 1],
[<font face="symbol">q</font>, 0] и [<font face="symbol">q</font> + <font face="symbol">l</font>, 1]. В результате в списке будет 3m записей, которые будут позднее упорядочены.</p>
m <- 0;<br>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="50%" valign="top"><p align="left">for (each peer)</td>
<td width="50%" valign="top"><p align="left">/*обращение ко всем партнерам */</td>
</tr>
</table>

if ({peer.reach &#8800; 0 and peer.dispersion < ntp.maxdisperse} and not (peer.stratum > 1
<b>И</b> peer.refid = peer.hostaddr)) begin<br>
<font face="symbol">l</font><br>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="50%" valign="top"><p align="left">andistance (peer);</td>
<td width="50%" valign="top"><p align="left">/* запись в список */</td>
</tr>
</table>

add [<font face="symbol">q</font> - <font face="symbol">l</font>, -1] to endpoint list;<br>
add [<font face="symbol">q</font>, 0] to endpoint list;<br>
add [<font face="symbol">q</font> + <font face="symbol">l</font>, 1] to endpoint list;<br>
m <- m + 1;<br>
&lt;B&gt;endif<br>
endfor<br>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="50%" valign="top"><p align="left">if (m = 0) begin</td>
<td width="50%" valign="top"><p align="left">/* уход, если кандидаты отсутствуют */</td>
</tr>
</table>

sys.peer <-  null;<br>
sys.stratum <- 0 (undefined);<br>
exit;<br>
endif<br>
sort endpoint list by increasing endpoint||type;<br>

<p align="justify">Ниже приведенный алгоритм представляет собой адаптированную версию DTS [DEC89] и сконструирован так, чтобы отбирать только истинных кандидатов. Алгоритм начинается с инициализации значения f и занесения нуля в счетчики i и c. Затем, начиная с конца упорядоченного, для каждой записи [указатель, тип] значение типа вычитается из кода счетчика i, который
содержит число пересечений. Если код типа равен нулю, инкрементируется значение <b>c</b>, которое регистрирует число ложных кандидатов. Если для некоторых записей i <font face="symbol">і</font> &#8805; m - f, конец записи становится нижней границей пересечения; в противном случае, f увеличивается на 1 и процедура повторяется. Без сброса значений f или c, аналогичная процедура используется для нахождения верхней границы, за исключением того, что
значение кода тип добавляется к счетчику. Если после того как обе границы определены c <font face="symbol">Ј</font> f, процедура продолжается для найденных m - f кандидатов, в противном случае, f увеличивается на 1 и вся процедура повторяется.</p>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="50%" valign="top"><p align="left">for (f from 0 to f &#8805; m/2) begin</td>
<td width="50%" valign="top"><p align="left">/* обращение ко всем кандидатам */</td>
</tr>
</table>

c <- 0;<br>
i <- 0;<br>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="62%" valign="top"><p align="left">for (each [endpoint, type] from lowest) begin</td>
<td width="38%" valign="top"><p align="left">/* нахождение нижней границы */</td>
</tr>
</table>

i <- i - type;<br>
low <- endpoint;<br>
if (i &#8805; m - f) break;<br>
if (type = 0) c <- c + 1;<br>
endfor;<br>
i <- 0;<br>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="60%" valign="top"><p align="justify">for (each [endpoint, type] from highest) begin</td>
<td width="40%" valign="top"><p align="justify">/* нахождение верхней границы */</td>
</tr>
</table>

i <- i + type;<br>
high <- endpoint;<br>
if (i &#8805; m - f) break;<br>
if (type = 0 ) c <- c + 1;<br>
endfor;<br>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="27%" valign="top"><p align="left">if (c &#8804; f) break;</td>
<td width="73%" valign="top"><p align="left">/* продолжить, пока не будут найдены все ложные
кандидаты */</td>
</tr>
</table>

endfor;<br>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="34%" valign="top"><p align="left">if (low > high) begin</td>
<td width="66%" valign="top"><p align="left">/* завершить, если не найдено ни одного
пересечения */</td>
</tr>
</table>

sys.peer <- null;<br>
exit;<br>
endif;<br>

<p align="justify">Заметим, что работа продолжается далее данной точки, только если имеется более m/2 пересечений. Однако возможно, но не слишком вероятно, что в области пересечения окажется менее m/2 кандидатов.</p>

<p align="justify"><b>Алгоритм кластеризации</b></p>

<p align="justify">В исходном алгоритме DTS процедура выбора часов прерывается в данной точке с выбором кандидатов из центра области пересечения. Однако это ведет к заметной потере точности и стабильности, так как не учитываются индивидуальные статистические свойства партнеров. Следовательно, в NTP только кандидаты, которые остаются в результате описанного выше отбора, могут участвовать в последующей обработке. Список кандидатов преобразуется к форме [расстояние, индекс], где расстояние вычисляется на основе кода слоя и расстояния синхронизации <font face="symbol">l</font> партнера.
Масштабный коэффициент позволяет реализовать механизм весового учета вкладов от кодов слоя и расстояния. Обычно, код слоя доминирует, если только один или более кандидатов имеют слишком большие расстояния. Список упорядочивается согласно величине расстояния.</p>
m <- 0;<br>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="50%" valign="top"><p align="justify">for (each peer) begin</td>
<td width="50%" valign="top"><p align="justify">/* обращение ко всем партнерам */</td>
</tr>
</table>

if (low &#8804; <font face="symbol">q</font> &#8804; high) begin<br>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="50%" valign="top"><p align="left"><font face="symbol">l</font> <- distance (peer);</td>
<td width="50%" valign="top"><p align="left">/* сформировать запись в списке */</td>
</tr>
</table>

dist <- {peer.stratum * NTP.MAXDISPERSE + <font face="symbol">l</font>}<br>
add [dist, peer] to candidate list;<br>
m <- m + 1;<br>
endif;<br>
endfor;<br>
sort candidate list by increasing dist;<br>

<p align="justify">Последующие шаги служат для того, чтобы отсеять кандидатов со слишком большими дисперсиями. Практика показывает, что число кандидатов здесь может быть достаточно велико. Это может привести к большому числу циклов повторения процедуры отбора, которые не дадут какого-либо улучшения результатов. Длина списка кандидатов ограничивается переменной
ntp.maxclock.</p>

<p align="justify">Заметим, что <font face="symbol">e<sub>x</font>i</sub> представляет собой дисперсию относительно i-го партнера из списка кандидатов, которая может быть вычислена методом дисперсии фильтра, описанным выше. <font face="symbol">e</font><sub>j</sub> - дисперсия j-ого партнера из списка, включающая в себя вклады от ошибок измерения, от накопления дрейфа и из-за
дисперсии фильтра. Если максимальное значение <font face="symbol">e<sub>x</font>i</sub> </font> больше
чем минимальное значение <font face="symbol">e</font><sub>j</sub>, а число кандидатов больше чем ntp.minclock, i-ый партнер удаляется из списка и процедура повторяется. Если текущий источник синхронизации является одним из членов списка и нет других кандидатов из более низкого слоя, процедура прерывается, и никакие другие последующие шаги не предпринимаются. В противном случае в качестве источника синхронизации берется первый кандидат из списка. В ниже приведенном тексте i, j, k, l - индексы партнеров, k - индекс текущего источника синхронизации (нуль, если такой источник отсутствует), l - индекс первого кандидата в списке.</p>
while begin<br>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="59%" valign="top"><p align="left">for (each survivor [distance, index]) begin</td>
<td width="41%" valign="top"><p align="left">/* вычисление дисперсии */</td>
</tr>
</table>

find index i for max <font face="symbol">e<sub>{x</font>i}</sub>;<br>
find index j for min <font face="symbol">e</font><sub>j</sub>;<br>
endfor<br>
if (<font face="symbol">e<sub>{x</font>i}</sub> &#8804; <font face="symbol">e</font><sub>j</sub> or
m &#8804; NTP.MINCLOCK) break;<br>

<table cellspacing=0 border=0 cellpadding=2 width=800>
<tr><td width="59%" valign="top"><p align="justify">peer.survivor [i] <- 0;</td>
<td width="41%" valign="top"><p align="justify">/* отбрасывание i-го партнера */</td>
</tr>
</table>

if (i = k) sys.peer <- null;<br>
delete the ith peer from the candidate list;<br>
m <- m - 1;<br>
endwhile<br>
if (peer.survivor [k] = 0 or peer.stratum [k] >> peer.stratum [l]) begin<br>
sys.peer <- l;     /* новый источник часов */<br>
call poll-update;<br>
endif<br>
end clock-select procedure;<br>

<p align="justify">Алгоритм сконструирован так, чтобы отдавать предпочтение партнерам из головной части списка, которые размещены в более низком слое, имеют наименьшее расстояние и могут обеспечить наибольшую точность и стабильность. С помощью правильного выбора весового коэффициента <b>v</b> (называемого ntp.select), можно удалить некоторые записи из финальной части списка.</p>

<p align="justify"><b>Локальные часы</b></p>

<p align="justify">Для того чтобы иметь точные локальные часы, ЭВМ должна быть оборудована аппаратными часами, состоящими из задающего генератора и интерфейса, обеспечивающего необходимые операции установки и коррекции. Логические часы конструируются, используя эти компоненты и программы, которые осуществляют подстройку частоты и абсолютного показания локальных часов. Такая
система позволяет достичь точности времени до 15 нс и стабильности частоты на уровне 0.3 мс в день. Предлагаемая модель удобна для применения как для компенсируемых, так и для некомпенсируемых кварцевых генераторов, пригодна она и для часов, использующих для создания временной шкалы частоту сети переменного тока.</p>

<p align="justify">Важно заметить, что конкретная описанная реализация является лишь одной из многих возможных.</p>

<p align="justify"><b>Реализация "пушистый шарик" (Fuzzball) </b></p>

<p align="justify">Локальные часы "пушистый шарик" представляют собой комбинация аппаратных и программных регистров, а также алгоритмов, которые осуществляют функционирование часов - работу управляемого задающего генератора, синхронизуемого от внешнего источника. Долее следует описание его компонент и способа работы. Заметим, что все числа представлены в представлении дополнений до 2, а все сдвиги являются арифметическими (заполнение знаком при сдвиге вправо и нулем при сдвиге влево).</p>

<p align="justify">48-битовый часовой регистр (clock) и 32-битовый предварительный счетчик (prescaler) образуют управляемый задающий генератор с периодом 1 мс. Дробная часть кода времени представляет число миллисекунд с начала суток. 32-битовый регистр коррекций (Clock-Adjust) используется для подстройки фазы часов постепенными шагами, что исключает неоднородности временной шкалы. Его содержимое обозначается <b>x</b>. 32-битовый регистр
компенсации дрейфа (Skew-Compensation) используется для подстройки частоты задающего генератора с помощью добавления небольших фазовых сдвигов (0,01%). Его содержимое обозначается символом <b>y</b>. 16-битовый счетчик оповещения (Watchdog) и 32-битный регистр согласования (Compliance) используются для определения корректности и служит также для задания периода рассылки запросов.
Содержимое регистра согласования обозначается символом <b>z</b>. 32-битовый регистр настройки (PPS-Adjust) служит для подстройки точности, когда имеется точный источник сигналов с периодом в одну секунду. 2-битовый регистр флагов управляет добавлением/вычитанием секунд к показаниям часов, когда это необходимо.</p>

<p align="justify">Все регистры кроме предварительного счетчика обычно размещаются в памяти. В типовом интерфейсе часов, таком как DEC KWV11-C, регистр prescaler реализован в виде 16-битового буферного счетчика, управляемого кварцевым генератором с частотой, кратной 1000 Гц. Переполнение
счетчика вызывает прерывание процессора, которое осуществляет приращение содержимого регистра часов.</p>

<p align="justify">Когда наступает момент подстройки, CLOCK.ADJ секунд вычитается из содержимого PPS-счетчика, но это CLOCK.ADJ делается лишь при условии, что там лежит число больше нуля. CLOCK.ADJ добавляется к коду счетчика Watchdog. Этот код не должен превышать значения NTP.MAXAGE,
поделенного на CLOCK.ADJ. Если счетчик Watchdog достигнет этой величины, часы считаются не синхронизованными, а Leap-биты устанавливаются равными 11<sub>2</sub>.</p>

<p align="justify"><b>Постепенная настройка фазы</b></p>

<p align="justify">Если локальные часы нескорректированы, они продолжают работать со смещением и частотой (при отсутствии дрейфа), установленными при последней коррекции. Корректирующая информация имеет формат 48-битного целого числа со знаком. Это число характеризует целое и дробное число миллисекунд (запятая располагается после 32-го двоичного разряда). Если полученная величина превосходит максимальное значение, заданное CLOCK.MAX, необходима постепенная
пошаговая коррекция. В норме величина поправки вычисляется в рамках алгоритма NTP. Однако, если код счетчика PPS больше нуля, вместо него должен использоваться регистр PPS-ADJUST. Пусть <b>u</b> представляет собой 32-битовый код с битами 0-31 равными разрядам 16-47 корректирующего кода. Если некоторые младшие биты корректирующего кода не используются, они устанавливаются
равными биту знака. Такие операции сдвигают положение запятой влево по отношению биту 16, что уменьшает влияние ошибок округления. Пусть <b>b</b> число начальных нулей в коде регистра Compliance и пусть <b>c</b> - число начальных нулей в коде счетчика W@atchdog. Тогда <b>b</b> установится  равным:</p>

<p align="justify">b = b - 16 + clock.comp</p>

<p align="justify"><b>b</b> не должно быть меньше нуля (это логарифм постоянной времени обратной связи). Затем установим <b>c</b> равным:</p>

<p align="justify">c = 10 - c</p>

<p align="justify">Величина <b>c</b> представляет собой логарифм времени интегрирования со времени последней коррекции. Затем вычисляются новые значения кодов для регистров CLOCK.ADJUST и Skew-Compensation. </p>

<p align="justify">x = u >> b, <br>
y = y + (u >> (b + b - c)).</p>

<p align="justify">В заключение вычисляем экспоненциальное среднее</p>

<p align="justify">z = z + (u << (b + clock.mult) - z) >> clock.weight,</p>

<p align="justify">где сдвиг влево переносит положения запятой с целью достижения большей точности.</p>

<p align="justify">Для каждого периода подстройки определяется корректирующий код из двух составляющих. Первая составляющая (фаза) определяется как</p>

<p align="justify">x >> clock.phase,</p>

<p align="justify">эта величина затем вычитается из предшествующего значения регистра Clock-Adjust. Результат становится новым значением кода этого регистра. Вторая компонента - (частота) определяется как</p>

<p align="justify">y >> clock.freq.</p>

<p align="justify">Совокупность фазы и частоты представляет собой окончательный корректирующий код, который затем добавляется к коду регистра (clock). В заключение, счетчик Watchdog обнуляется.</p>

<p align="justify">Величина <b>b</b> вычисленная ранее может использоваться для изменения величины системной переменной, характеризующей период запросов (коррекций) sys.poll.</p>

<p align="justify">sys.poll <- b + NTP.MINPOLL.</p>

<p align="justify">При условии, что шум коррекций велик, частота аппаратного задающего генератора может меняться быстро из-за изменений условий окружающей среды. В этом случае период запросов укорачивается. Когда шум незначителен, задающий генератор стабилен и период запросов растет вплоть до NTP.MAXPOLL секунд.</p>

<p align="justify"><b>Ступенчатая подстройка фазы</b></p>

<p align="justify">Когда величина поправки превышает CLOCK.MAX, имеется возможность того, что часы окажутся настолько не синхронизованы, что наилучшим решением будет немедленная замена содержимого регистра часов. Однако, в случаях, когда вариация записи весьма высока, разумно не поверить в возможность скачкообразного изменения, если только со времени последней коррекции не
прошло достаточно много времени. Следовательно, если обнаружено скачкообразное изменение, а счетчик Watchdog содержит код меньше предварительно установленного значения CLOCK.MINSTEP, корректирующее сообщение игнорируется.</p>

<p align="justify">Если обнаружено ступенчатое изменение, коррекция заносится непосредственно в регистры Clock, а содержимое регистров Clock-Adjust и Watchdog обнуляется. Другие же регистры остаются без изменений. Так как ступенчатое изменение показаний указывает на некорректность информации в часовых фильтрах (clock filters), биты добавления делаются равными 112 (не
синхронизовано) и вызывается процедура очистки часовых фильтров и переменных состояния для всех партнеров. На практике необходимость корректировать показания часов скачкообразно случается крайне редко, когда, например, локальные часы или эталон перезагружаются.</p>

<p align="justify">Практически значения CLOCK.MAX могут быть превышены временным сервером лишь в условиях чрезмерной перегрузки канала или при сбоях оборудования. Наиболее часто встречаемый случай - это смена сервера при регистрации слишком большого числа ошибок или из-за сильной вариации задержки. Рекомендуется, чтобы реализации программ включали средства формирования
значений CLOCK.MAX для особых случаев. Величина, на которую можно превысить CLOCK.MAX, не нарушая требования монотонности, зависит от значения приращения регистра часов (Clock Register).</p>

<p align="justify"><b>Обсуждение реализации</b></p>

<p align="justify">Базовая модель надежности NTP предполагает, что не должно быть никаких других способов изменения показаний кроме предусмотренных самим протоколом NTP. Системы с часами-календарем, имеющие питание от батареи или аккумулятора, считаются надежными, но менее точными, чем использующие NTP-синхронизацию. При последовательных коррекциях, если величина поправки превышает конфигурационный параметр (напр., 1000 секунд), поправка отбрасывается и посылается сообщение об ошибке. Некоторые реализации периодически записывают содержимое регистра Skew-Compensation (компенсация дрейфа) в системный файл или в NVRAM (память, сохраняемая при
отключении питания).</p>

<p align="justify">Преобразование из формата NTP в обычный информационный формат осуществляется прикладными программами. В день накануне добавления/вычитания секунды из показаний времени значение sys.leap устанавливается на первичном сервере вручную. Следует иметь в виду, что
большинство радио-часов не имеет автоматических или ручных средств добавления/вычитания секунд. Но даже в случае некорректного добавления/вычитания секунды локальные часы будут вновь синхронизованы не позднее чем через число секунд, заданное CLOCK.MINSTEP.</p>


<font size=4><p align="center"><b>Приложение А. Формат данных NTP - версия 3</b></p></FONT>

<p align="justify">Формат NTP-сообщения, которое следует сразу после UDP-заголовка, показан на рис 4.4.15.1.</p>

<p align="justify"><b><i> Индикатор добавления</i> (LI - leap indicator) - </b>двухбитовое поле предупреждения о предстоящем добавлении/вычитании секунды к последней минуте текущего дня. Значения этих битов смотри в таблице 4.4.15.1.</p>

<p align="center"><img src="ntp1.jpg" tppabs="http://book.itep.ru/4/44/ntp1.jpg"></p>
<p align="center">Рис. 4.4.15.1. Формат сообщения NTP.</p>

<p align="justify"><b><i>Номер версии</i> (VN) -</b> трехбитовое поле, указывающее на номер версии протокола NTP, в настоящее время (3).</p>

<p align="justify"><b><i>Режим</i> (Mode) </b>- трехбитовое поле, определяющее режим, значения кодов режима приведены в таблице<b> </b>4.4.15.2. </p>

<p align="justify"><b> <i> Слой</b></i> (Stratum) - 8-битовое поле, определяющее код слоя, где работают локальные часы. Коды слоя представлены в таблице 4.4.15.3. Возможные значения кодов лежат в интервале от нуля до NTP.INFIN включительно.</p>

<p align="justify"><b><i>Период запросов</i> (poll interval) </b>- 8-битовое поле, указывающее на максимальное значение интервала между запросами.<b> </b>Код, записанный в этом поле, интерпретируется как целое число со знаком и характеризует значение периода в секундах, как ближайшее к величине степени двух. Коды, которые могут быть записаны в этом поле, должны лежать в
интервале между NTP.MAXPOLL и NTP.MAXPOLL включительно.</p>

<p align="justify"><b><i>Точность</i> (precision) -</b> 8-битовое поле, обозначающее точность локальных часов в секундах. Код поля интерпретируется как целая степень со знаком числа 2.</p>

<p align="justify"><b><i>Базовая задержка</i> (Root Delay) -</b> 32-битовое поле, характеризующее RTT до эталонного источника в секундах. Код поля интерпретируется как число с фиксированной запятой, размещенной между битами 15 и 16. Заметим, что величина этого кода может иметь и отрицательное значение (зависит от точности часов и величины дрейфа).</p>

<p align="justify"><b><i>Базовая дисперсия</i> (Root Dispersion) -</b> 32-битовое поле, определяющее максимальную ошибку по отношению к эталонному источнику в секундах. Код поля интерпретируется как число с фиксированной запятой (между 15 и 16 битами). Допустимы только положительные значения.</p>

<p align="justify"><b><i>Идентификатор эталонных часов</i> (Reference Clock Identifier) -</b> 32-битовое поле, идентифицирующее конкретные эталонные часы. В случае кода слоя нуль (не специфицировано) или слоя 1 (первичный эталон), это 4-октетная комбинация выравнивается по левому краю и дополняется нулями (ASCII). Когда идентификатор в NTP не специфицирован, предлагаются
ascii- идентификаторы, приведенные в таблице 4.4.15.4.</p>

<p align="justify">В случае слоя 2 и больше (вторичный эталон) - это 4-октетный IP-адрес ЭВМ - первичного эталона.</p>

<p align="justify"><b><i>Эталонная временная метка</i> (Reference Timestamp) -</b> поле локального времени (64-битовый формат временных меток), когда часы корректировались в последний раз.</p>

<p align="justify"><b><i>Исходная временная метка</i> (Originate Timestamp)</b> определяет время, когда запрос направлен серверу (стандартный 64-битовый формат временных меток).</p>

<p align="justify"><b><i>Получаемая временная метка</i> (Receive Timestamp) -</b> время, когда запрос прибыл к серверу (стандартный 64-битовый формат временных меток). </p>

<p align="justify"><b><i>Передаваемая временная метка</i> (Transmit Timestamp) -</b> локальное время, когда послан отклик сервером (стандартный 64-битовый формат временных меток).</p>

<p align="justify"><b><i>Аутентификатор</i> (authenticator) (опционно) -</b> поле, содержащее аутентификационную информацию. Используется лишь в случае реализации NTP-аутентификации.</p>

<p align="center"><b><font size=4> Приложение Б. Сообщения управления NTP</b></font></p>

<p align="justify">В сетевой среде должны быть средства управления программами NTP, такие как установка индикатора добавления секунды (Leap-Indicator) со стороны первичного сервера, настройка различных системных параметров и процедур мониторинга. Такие операции могут быть реализованы с привлечением протокола snmp и соответствующего расширения базы данных MIB. Однако в тех случаях,
когда такие средства недоступны, эти функции могут быть реализованы с помощью специальных управляющих NTP-сообщений.</p>

<p align="justify">Управляющие сообщения NTP имеют код 6 в поле режима первого октета NTP-заголовка. Формат поля данных специфичен для каждой из команд или отклика. Однако, в большинстве случаев формат конструируется так, чтобы облегчить его непосредственное чтение. Как правило, он состоит из ASCII-строк. Если используется аутентификатор, поле данных дополняется нулями до границы, кратной целому числу 32-битных слов.</p>

<p align="justify">IP-ЭВМ не должны обрабатывать дейтограммы длиннее 576 октетов; однако, некоторые команды или отклики могут содержать данные, непомещающиеся в одну дейтограмму. Для решения данной проблемы все октеты сообщения нумеруются, начиная с нуля. При передаче фрагментов
сообщения номер первого октета записывается в поле смещения (offset), а число октетов в поле длины. Бит (M - more) устанавливается во всех фрагментах за исключением последнего.</p>

<p align="justify">Большинство контрольных функций включает посылку команды и получение отклика. Отправитель выбирает ненулевой порядковый номер и устанавливает статусное поле и биты R и E равными нулю. Получатель интерпретирует код операции и дополнительную информацию, содержащуюся
в поле данных, вносит изменение в поле статуса и устанавливает бит R=1, а также возвращает три 32-битного слова заголовка вместе с другой дополнительной информацией поля данных. В случае неверного формата сообщения или ошибки в поле данных получатель заносит соответствующий код в поле статуса, устанавливает биты R и E равными 1, и опционно записывает диагностическое сообщение
в поле данных.</p>

<p align="justify">Некоторые команды осуществляют чтение или запись для системных переменных и переменных партнеров для ассоциации, идентифицированной в команде. Другие читают или записывают значения переменных, связанных с радио-часами и другими приборами, имеющими непосредственное отношение к эталонам времени. Для определения ассоциации используется ее 16-битовый идентификатор.
Для системных переменных используется идентификатор нуль. Управляющий объект может затребовать текущий список идентификаторов с тем, чтобы их использовать в дальнейшем. При попытке употребить уже недействительный идентификатор будет прислан соответствующий отклик, после чего необходимо запросить список идентификаторов еще раз.</p>

<p align="justify">Некоторые события, такие как изменение статуса доступа к партнеру, не сопряжены с какими-либо командами и происходят асинхронно. Программа может запоминать информацию о таких событиях и пересылать ее в откликах. Текущий статус и краткая аннотация чрезвычайных событий
пересылаются каждым откликом. Биты в статусном поле указывают на то, произошло ли какое-либо событие с момента предыдущего отклика и было ли их больше одного.</p>

<p align="justify"><b> Формат сообщений управления NTP</b> </p>

<p align="justify">Формат заголовков управляющих NTP-сообщений показан на рис. 4.4.15.2. Этот заголовок располагается непосредственно вслед за UDP-заголовком.</p>

<p align="center"><img src="ntp2.jpg" tppabs="http://book.itep.ru/4/44/ntp2.jpg"></p>
<p align="center">Рис. 4.4.15.2. Формат управляющего сообщения ntp</p>

<p align="justify">Первые два бита, обозначенные ZZ, должны всегда содержать 0.</p>

<p align="justify"><b><i>Номер версии</i> (VN - version number) -</b> трехбитовое поле, указывающее на номер версии протокола NTP, в настоящее время (3).</p>

<p align="justify"><b><i>Режим</i> (Mode) -</b> трехбитовое поле, определяющее режим, значение кода режима для управляющих сообщений равно 6.</p>

<p align="justify"><b><i>Бит отклика</i> (R) -</b> равен нулю для команд и 1 для откликов.</p>

<p align="justify"><b><i>Бит ошибки</i> (E) -</b> равен нулю для нормального отклика и 1 в случае ошибки.</p>

<p align="justify"><b><i>Бит продолжения</i> (M - more) -</b> равен нулю для последнего фрагмента и 1 - для всех остальных.</p>

<p align="justify"><b><i> Код операции</i> (OP) -</b> 5-битовое поле, определяющее код команды. Значения кодов и их функции представлены в таблице 4.4.15.5.</p>

<p align="center"><b>Таблица 4.4.15.5.</b> Коду операции управляющего сообщения</p>

<center><table border=10 cellspacing=1 cellpadding=5 width=800 bgcolor="ghostwhite">
<tr><td width="15%" valign="top" bgcolor="gainsboro"><p align="center">Код</td>
<td width="85%" valign="top" bgcolor="gainsboro"><p align="justify">Функция</td>
</tr>
<tr><td width="15%" valign="top"><p align="center">0</td>
<td width="85%" valign="top"><p align="justify">Зарезервировано</td>
</tr>
<tr><td width="15%" valign="top"><p align="center">1</td>
<td width="85%" valign="top"><p align="justify">чтение статуса команда/отклик</td>
</tr>
<tr><td width="15%" valign="top"><p align="center">2</td>
<td width="85%" valign="top"><p align="justify">чтение переменной команда/отклик</td>
</tr>
<tr><td width="15%" valign="top"><p align="center">3</td>
<td width="85%" valign="top"><p align="justify">запись переменной команда/отклик </td>
</tr>
<tr><td width="15%" valign="top"><p align="center">4</td>
<td width="85%" valign="top"><p align="justify">чтение переменных часов команда/отклик </td>
</tr>
<tr><td width="15%" valign="top"><p align="center">5</td>
<td width="85%" valign="top"><p align="justify">запись переменных часов команда/отклик </td>
</tr>
<tr><td width="15%" valign="top"><p align="center">6</td>
<td width="85%" valign="top"><p align="justify">установка адреса/порта trap команда/отклик</td>
</tr>
<tr><td width="15%" valign="top"><p align="center">7</td>
<td width="85%" valign="top"><p align="justify">отклик на Trap </td>
</tr>
<tr><td width="15%" valign="top"><p align="center">8-31</td>
<td width="85%" valign="top"><p align="justify">Зарезервировано на будущее</td>
</tr>
</table></center></p>

<p align="justify"><b><i> Порядковый номер</i> (Sequence) -</b> 16-битовое поле, определяющее номер запроса или отклика, и облегчающее определения их соответствия.</p>

<p align="justify"><b><i>Статус</i> -</b> 16-битовое поле, содержащее код статуса системы, партнера или часов.</p>

<p align="justify"><b><i>Идентификатор ассоциации</i> (Association ID) -</b> 16-битовое поле, несущее в себе идентификатор ассоциации.</p>

<p align="justify"><b><i>Смещение</i> (Offset) -</b> 16-битовое поле, определяющее положение первого октета поля данных в сообщении, передаваемом в нескольких дейтограммах (позиция задается в октетах).</p>

<p align="justify"><b><i>Длина</i> (Count) -</b> 16-битовое поле, определяющее длину поля данных в октетах.</p>

<p align="justify"><b><i> Данные</i> -</b> это поле содержит информацию сообщения, как для команды, так и для отклика. Максимальное число октетов в поле данных равно 468.</p>

<p align="justify"><b><i> Аутентификатор</i> (опционно). </b>Поле, содержащие аутентификационную информацию. Используется лишь в случае реализации NTP-аутентификации.</p>

<p align="justify"><b> Статусные слова</b> </p>

<p align="justify">Статусные слова указывают на текущее состояние системы ассоциации и часов. Эти слова интерпретируются программами сетевого мониторинга и имеют 4 разных 16-битовых форматов. Статусные слова партнеров и системы соответствуют откликам для всех команд за исключением случая
чтения/записи переменных часов и установки адреса/порта для TRAP. Идентификатор ассоциации нуль соответствует системным статусным словам, в то время как ненулевой идентификатор указывает на какую-то конкретную ассоциацию. Статусное слово, присланное в ответ на команду чтения или записи переменной часов, указывает на состояние оборудования и кодирующего программного обеспечения.</p>

<p align="justify"><b> Системные статусные слова</b> </p>

<p align="justify">Системное статусное слово может присутствовать в статусном поле отклика. Системное статусное слово имеет следующий формат.</p>

<p align="justify"><b> Индикатор добавления (LI - leap indicator) -</b> двухбитовое поле предупреждения о предстоящем добавлении/вычитании секунды к последней минуте текущего дня. Значения этих битов смотри в таблице 4.4.15.1.</p>

<p align="justify"><b> Источник часов (clock source) -</b> 6-битовое поле, указывающее на используемый в данный момент источник синхронизации. Назначение кодов этого поля описано в таблице <b>4.4.15.6</b>. </p>

<p align="center">Таблица <b>4.4.15.6</b>. Коды источников временного эталона</p>

<center> <table border=10 cellspacing=1 cellpadding=5 width=750 bgcolor="ghostwhite">
<tr><td width="15%" valign="top" bgcolor="gainsboro"><p align="center">Код</td>
<td width="85%" valign="top" bgcolor="gainsboro"><p align="justify">Функция</td>
</tr>
<tr><td width="15%" valign="top"><p align="center">0</td>
<td width="85%" valign="top"><p align="justify">Не специфицирован или неизвестен </td>
</tr>
<tr><td width="15%" valign="top"><p align="center">1</td>
<td width="85%" valign="top"><p align="justify">Калиброванные атомные часы (напр., hp 5061)</td>
</tr>
<tr><td width="15%" valign="top"><p align="center">2</td>
<td width="85%" valign="top"><p align="justify">vlf (диапазон 4) или НЧ (диапазон 5) радио
(напр., omega, wwvb)</td>
</tr>
<tr><td width="15%" valign="top"><p align="center">3</td>
<td width="85%" valign="top"><p align="justify">ВЧ (диапазон 7) радио (напр., chu, msf, wwv/h)</td>
</tr>
<tr><td width="15%" valign="top"><p align="center">4</td>
<td width="85%" valign="top"><p align="justify">УВЧ (диапазон 9) спутник (напр., goes, gps)</td>
</tr>
<tr><td width="15%" valign="top"><p align="center">5</td>
<td width="85%" valign="top"><p align="justify">Локальная сеть (напр., dcn, tsp, dts)</td>
</tr>
<tr><td width="15%" valign="top"><p align="center">6</td>
<td width="85%" valign="top"><p align="justify">UDP/NTP</td>
</tr>
<tr><td width="15%" valign="top"><p align="center">7</td>
<td width="85%" valign="top"><p align="justify">UDP/time</td>
</tr>
<tr><td width="15%" valign="top"><p align="center">8</td>
<td width="85%" valign="top"><p align="justify">eyeball-and-wristwatch</td>
</tr>
<tr><td width="15%" valign="top"><p align="center">9</td>
<td width="85%" valign="top"><p align="justify">Телефонный модем (напр., nist)</td>
</tr>
<tr><td width="15%" valign="top"><p align="center">10-63</td>
<td width="85%" valign="top"><p align="justify">Зарезервировано на будущее</td>
</tr>
</table></center> </p>

<p align="justify"><b> Системный счетчик событий -</b> четырех битовое целое число, обозначающее число событий, происшедших с момента последнего получения статусного слова системы. Счетчик обнуляется, когда присылается в статусном поле отклика и остается неизменным после достижения значения 15.</p>

<p align="justify"><b> Код системного события -</b> четырехбитовое число, идентифицирующее последнее системное событие, новое значение переписывает предыдущее. Коды событий перечислены в таблице <b>4.4.15.7</b>.</p>

<p align="center">Таблица <b>4.4.15.7</b>. Коды системных событий</p>

<center> <table border=10 cellspacing=1 cellpadding=5 width=750 bgcolor="ghostwhite">
<tr><td width="10%" valign="top" bgcolor="gainsboro"><p align="center">Код</td>
<td width="90%" valign="top" bgcolor="gainsboro"><p align="justify">Функция</td>
</tr>
<tr><td width="10%" valign="top"><p align="center">0</td>
<td width="90%" valign="top"><p align="justify">Не специфицировано</td>
</tr>
<tr><td width="10%" valign="top"><p align="center">1</td>
<td width="90%" valign="top"><p align="justify">Рестарт системы</td>
</tr>
<tr><td width="10%" valign="top"><p align="center">2</td>
<td width="90%" valign="top"><p align="justify">Системный или аппаратный сбой </td>
</tr>
<tr><td width="10%" valign="top"><p align="center">3</td>
<td width="90%" valign="top"><p align="justify">Новое статусное слово системы (изменение битов
добавления или синхронизации)</td>
</tr>
<tr><td width="10%" valign="top"><p align="center">4</td>
<td width="90%" valign="top"><p align="justify">Новый источник синхронизации или слой (изменение
sys.peer или sys.stratum)</td>
</tr>
<tr><td width="10%" valign="top"><p align="center">5</td>
<td width="90%" valign="top"><p align="justify">Сброс системных часов (корректирующая добавка
превысила clock.max)</td>
</tr>
<tr><td width="10%" valign="top"><p align="center">6</td>
<td width="90%" valign="top"><p align="justify">Некорректное системное время или дата</td>
</tr>
<tr><td width="10%" valign="top"><p align="center">7</td>
<td width="90%" valign="top"><p align="justify">system clock exception </td>
</tr>
<tr><td width="10%" valign="top"><p align="center">8-15</td>
<td width="90%" valign="top"><p align="justify">Зарезервировано на будущее</td>
</tr>
</table></center>

<p align="justify"><b> Статусное слово партнера </b> </p>

<p align="justify">Статусное слово партнера возвращается в статусном поле отклика на команду чтения статуса, а также чтения или записи переменных. Это слово появляется в списке идентификаторов ассоциации и статусных слов, присылаемых в ответ на команду чтения статуса с нулевым идентификатором ассоциации. Формат статусного слова партнера содержит следующие поля
(рис. 4.4.15.3)</p>

<p align="center"><img src="status.gif" tppabs="http://book.itep.ru/4/44/status.gif"></P>
<P ALIGN="CENTER">Рис. 4.4.15.3. Форматы статусных слов</P>

<P ALIGN="JUSTIFY"><B>Статус партнера -</B> 5-битный код, характеризующий состояние партнера, определяемого процедурой обмена. Значения этого поля представлены в таблице <B>4.4.15.8</B>.</P>

<P ALIGN="CENTER">Таблица <B>4.4.15.8</B>. Коды состояния партнера</P>

<CENTER><TABLE BORDER=10 CELLSPACING=1 CELLPADDING=5 WIDTH=750 bgcolor="ghostwhite">
<TR><TD WIDTH="23%" VALIGN="TOP" bgcolor="gainsboro"><P ALIGN="CENTER">Значение кода</TD>
<TD WIDTH="77%" VALIGN="TOP" bgcolor="gainsboro"><P ALIGN="JUSTIFY">Функция</TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP"><P ALIGN="CENTER">0</TD>
<TD WIDTH="77%" VALIGN="TOP"><P ALIGN="JUSTIFY">Сконфигурирован (peer.config)</TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP"><P ALIGN="CENTER">1</TD>
<TD WIDTH="77%" VALIGN="TOP"><P ALIGN="JUSTIFY">Разрешена аутентификация (peer.authenable)</TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP"><P ALIGN="CENTER">2</TD>
<TD WIDTH="77%" VALIGN="TOP"><P ALIGN="JUSTIFY">Аутентификация успешна (peer.authentic)</TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP"><P ALIGN="CENTER">3</TD>
<TD WIDTH="77%" VALIGN="TOP"><P ALIGN="JUSTIFY">Партнер доступен (peer.reach)</TD>
</TR>
<TR><TD WIDTH="23%" VALIGN="TOP"><P ALIGN="CENTER">4</TD>
<TD WIDTH="77%" VALIGN="TOP"><P ALIGN="JUSTIFY">Зарезервировано на будущее</TD>
</TR></TABLE></CENTER>

<P ALIGN="JUSTIFY"><B> Выбор партнера (Sel) -</B> 3-битный код, говорящий о состоянии партнера, определенного в результате процедуры выбора часов. Значения кодов представлены в таблице <B>4.4.15.9</B>.</P>

<P ALIGN="CENTER">Таблица <B>4.4.15.9</B>. Коды выбора партнера</P>

<CENTER><TABLE BORDER=10 CELLSPACING=1 CELLPADDING=5 WIDTH=750 bgcolor="ghostwhite">
<TR><TD WIDTH="14%" VALIGN="TOP" bgcolor="gainsboro"><P ALIGN="CENTER">Значение кода</TD>
<TD WIDTH="86%" VALIGN="TOP" bgcolor="gainsboro"><P ALIGN="JUSTIFY">Функция</TD>
</TR>
<TR><TD WIDTH="14%" VALIGN="TOP"><P ALIGN="CENTER">0</TD>
<TD WIDTH="86%" VALIGN="TOP"><P ALIGN="JUSTIFY">Отклонен </TD>
</TR>
<TR><TD WIDTH="14%" VALIGN="TOP"><P ALIGN="CENTER">1</TD>
<TD WIDTH="86%" VALIGN="TOP"><P ALIGN="JUSTIFY">Проверка соответствия прошла успешно (тесты 1 - 8)</TD>
</TR>
<TR><TD WIDTH="14%" VALIGN="TOP"><P ALIGN="CENTER">2</TD>
<TD WIDTH="86%" VALIGN="TOP"><P ALIGN="JUSTIFY">Прошел проверки корректности (алгоритм пересечения)</TD>
</TR>
<TR><TD WIDTH="14%" VALIGN="TOP"><P ALIGN="CENTER">3</TD>
<TD WIDTH="86%" VALIGN="TOP"><P ALIGN="JUSTIFY">Прошел проверки, как кандидат</TD>
</TR>
<TR><TD WIDTH="14%" VALIGN="TOP"><P ALIGN="CENTER">4</TD>
<TD WIDTH="86%" VALIGN="TOP"><P ALIGN="JUSTIFY">Проверка ресурсов прошла успешно (алгоритм кластеризации)</TD>
</TR>
<TR><TD WIDTH="14%" VALIGN="TOP"><P ALIGN="CENTER">5</TD>
<TD WIDTH="86%" VALIGN="TOP"><P ALIGN="JUSTIFY">Текущий источник синхронизации; превышено максимальное расстояние (если используются предельные проверки)</TD>
</TR>
<TR><TD WIDTH="14%" VALIGN="TOP"><P ALIGN="CENTER">6</TD>
<TD WIDTH="86%" VALIGN="TOP"><P ALIGN="JUSTIFY">Текущий источник синхронизации; максимальное расстояние в пределах нормы</TD>
</TR>
<TR><TD WIDTH="14%" VALIGN="TOP"><P ALIGN="CENTER">7</TD>
<TD WIDTH="86%" VALIGN="TOP"><P ALIGN="JUSTIFY">Зарезервировано на будущее</TD>
</TR>
</TABLE></CENTER>

<P ALIGN="JUSTIFY"><B> Счетчик событий партнера -</B> 4-битовое число событий (exception) партнера, которые имели место со времени последнего получения статусного слова в рамках отклика или сообщения TRAP. Счетчик сбрасывается при занесении кода в поле статуса отклика, и перестает изменяться при достижении значения 15.</P>

<P ALIGN="JUSTIFY"><B> Код события партнера -</B> 4-битовое целое число, идентифицирующее последнее событие партнера. Новое значение переписывает предыдущее. Значения кодов представлены в таблице <B>4.4.15.10</B>.</P>

<P ALIGN="CENTER">Таблица <B>4.4.15.10</B>. Коды события партнера</P>>

<CENTER> <TABLE BORDER=10 CELLSPACING=1 CELLPADDING=5 WIDTH=800 bgcolor="ghostwhite">
<TR><TD WIDTH="17%" VALIGN="TOP" bgcolor="gainsboro"><P ALIGN="CENTER">Значение кода</TD>
<TD WIDTH="83%" VALIGN="TOP" bgcolor="gainsboro"><P ALIGN="JUSTIFY">Функция</TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><P ALIGN="CENTER">0</TD>
<TD WIDTH="83%" VALIGN="TOP"><P ALIGN="JUSTIFY">Не специфицировано</TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><P ALIGN="CENTER">1</TD>
<TD WIDTH="83%" VALIGN="TOP"><P ALIGN="JUSTIFY">IP-ошибка партнера</TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><P ALIGN="CENTER">2</TD>
<TD WIDTH="83%" VALIGN="TOP"><P ALIGN="JUSTIFY">Ошибка аутентификации партнера (бит peer.authentic был равен 1, а теперь =0)</TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><P ALIGN="CENTER">3</TD>
<TD WIDTH="83%" VALIGN="TOP"><P ALIGN="JUSTIFY">Партнер не достижим (peer.reach стал равен нулю)</TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><P ALIGN="CENTER">4</TD>
<TD WIDTH="83%" VALIGN="TOP"><P ALIGN="JUSTIFY">Партнер достижим (peer.reach стал не равен нулю)</TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><P ALIGN="CENTER">5</TD>
<TD WIDTH="83%" VALIGN="TOP"><P ALIGN="JUSTIFY">Проблема с часами партнера</TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><P ALIGN="CENTER">6-15</TD>
<TD WIDTH="83%" VALIGN="TOP"><P ALIGN="JUSTIFY">Зарезервировано на будущее</TD>
</TR>
</TABLE></CENTER>

<P ALIGN="JUSTIFY"><B> Слово состояния часов</B> </P>

<P ALIGN="JUSTIFY">Существует два способа подключить эталонные часы к NTP-серверу, как специальный прибор, поддерживаемый операционной системой или как партнера, управляемого NTP. Как и в случае команды чтения статуса идентификатор ассоциации определяет, часы какого из партнеров имеются в виду.
При нулевом идентификаторе речь идет о системных часах. Протокол поддерживает только одни системные часы, число часов-партнеров практически не ограничено. Статусное слово часов системы или партнера записывается в поле статуса отклика на команды чтения или записи переменных, характеризующих часы. Это слово может рассматриваться как расширение системного статусного слова или статусного слова партнера. Формат слова описан ниже (См. также рис. 4.4.15.3).</P>

<P ALIGN="JUSTIFY"><B> Состояние часов -</B> 8-битовое число, характеризующее текущее состояние часов. Допустимые значения этого числа и их смысл представлены в таблице <B>4.4.15.11</B>.</P>

<P ALIGN="CENTER">Таблица <B>4.4.15.11</B>. Коды состояния часов</P>

<CENTER><TABLE BORDER=10 CELLSPACING=1 CELLPADDING=5 WIDTH=750 bgcolor="ghostwhite">
<TR><TD WIDTH="22%" VALIGN="TOP" bgcolor="gainsboro"><P ALIGN="CENTER">Код</TD>
<TD WIDTH="78%" VALIGN="TOP" bgcolor="gainsboro"><P ALIGN="JUSTIFY">Функция</TD>
</TR>
<TR><TD WIDTH="22%" VALIGN="TOP"><P ALIGN="CENTER">0</TD>
<TD WIDTH="78%" VALIGN="TOP"><P ALIGN="JUSTIFY">Работа часов в пределах нормы</TD>
</TR>
<TR><TD WIDTH="22%" VALIGN="TOP"><P ALIGN="CENTER">1</TD>
<TD WIDTH="78%" VALIGN="TOP"><P ALIGN="JUSTIFY">Таймаут ответа </TD>
</TR>
<TR><TD WIDTH="22%" VALIGN="TOP"><P ALIGN="CENTER">2</TD>
<TD WIDTH="78%" VALIGN="TOP"><P ALIGN="JUSTIFY">Плохой формат ответа </TD>
</TR>
<TR><TD WIDTH="22%" VALIGN="TOP"><P ALIGN="CENTER">3</TD>
<TD WIDTH="78%" VALIGN="TOP"><P ALIGN="JUSTIFY">Сбой оборудования или программы</TD>
</TR>
<TR><TD WIDTH="22%" VALIGN="TOP"><P ALIGN="CENTER">4</TD>
<TD WIDTH="78%" VALIGN="TOP"><P ALIGN="JUSTIFY">Потеря при передаче </TD>
</TR>
<TR><TD WIDTH="22%" VALIGN="TOP"><P ALIGN="CENTER">5</TD>
<TD WIDTH="78%" VALIGN="TOP"><P ALIGN="JUSTIFY">Неверный формат или значение даты </TD>
</TR>
<TR><TD WIDTH="22%" VALIGN="TOP"><P ALIGN="CENTER">6</TD>
<TD WIDTH="78%" VALIGN="TOP"><P ALIGN="JUSTIFY">Неверный формат или значение времени</TD>
</TR>
<TR><TD WIDTH="22%" VALIGN="TOP"><P ALIGN="CENTER">7-255</TD>
<TD WIDTH="78%" VALIGN="TOP"><P ALIGN="JUSTIFY">Зарезервировано на будущее</TD>
</TR>
</TABLE></CENTER>

<P ALIGN="JUSTIFY"><B> Код события для часов -</B> 8-битовый код, идентифицирующий последнее событие для данных часов (exception). Новое значение переписывает предыдущее значение кода. Когда значение кода становится ненулевым для поля статуса радио-часов, этот код копируется в статусное поле кода события и считается, что произошло событие для системных часов или часов партнера.</P>

<P ALIGN="JUSTIFY"><B> Слово состояния ошибки</B> </P>

<P ALIGN="JUSTIFY">Статусное слово ошибки присылается в поле статуса отклика, если обнаружена ошибка в формате сообщения или в его содержимом. Его присутствие указывается равенствами E (error) и R (response) битов 1. Коды ошибки и их значения собраны в таблице <B>4.4.15.12</B>. </P>

<P ALIGN="CENTER">Таблица <B>4.4.15.12</B>. Коды ошибки</P>

<P ALIGN="CENTER"><CENTER><TABLE BORDER=10 CELLSPACING=1 CELLPADDING=5 WIDTH=750 bgcolor="ghostwhite">
<TR><TD WIDTH="20%" VALIGN="TOP" bgcolor="gainsboro"><P ALIGN="CENTER">Код ошибки </TD>
<TD WIDTH="80%" VALIGN="TOP" bgcolor="gainsboro"><P ALIGN="JUSTIFY">Значение</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P ALIGN="CENTER">0</TD>
<TD WIDTH="80%" VALIGN="TOP"><P ALIGN="JUSTIFY">Не специфицировано</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P ALIGN="CENTER">1</TD>
<TD WIDTH="80%" VALIGN="TOP"><P ALIGN="JUSTIFY">Неудачная аутентификация </TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P ALIGN="CENTER">2</TD>
<TD WIDTH="80%" VALIGN="TOP"><P ALIGN="JUSTIFY">Неверный формат или длина сообщения </TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P ALIGN="CENTER">3</TD>
<TD WIDTH="80%" VALIGN="TOP"><P ALIGN="JUSTIFY">Неверный код операции </TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P ALIGN="CENTER">4</TD>
<TD WIDTH="80%" VALIGN="TOP"><P ALIGN="JUSTIFY">Неизвестный идентификатор ассоциации</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P ALIGN="CENTER">5</TD>
<TD WIDTH="80%" VALIGN="TOP"><P ALIGN="JUSTIFY">Неизвестное имя переменной </TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P ALIGN="CENTER">6</TD>
<TD WIDTH="80%" VALIGN="TOP"><P ALIGN="JUSTIFY">Неверное значение переменной </TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P ALIGN="CENTER">7</TD>
<TD WIDTH="80%" VALIGN="TOP"><P ALIGN="JUSTIFY">Административно запрещено </TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP"><P ALIGN="CENTER">8-255</TD>
<TD WIDTH="80%" VALIGN="TOP"><P ALIGN="JUSTIFY">Зарезервировано на будущее</TD>
</TR>
</TABLE></CENTER></P>

<P ALIGN="JUSTIFY"><B> Команды</B> </P>

<P ALIGN="JUSTIFY">Команды состоят из заголовка и опционного поля данных. Если поле данных присутствует, оно включает в себя список идентификаторов и, возможно, их значений.</P>

<P ALIGN="JUSTIFY"><identifier>[=<value>],<identifier>[=<value>],...</P>

<P ALIGN="JUSTIFY">где <identifier> представляет собой имя переменной системы или партнера в форме ASCII-последовательности, а <value> является десятичным или шестнадцатеричным числом, или строкой, соответствующей синтаксису языка C. Для большей читаемости допускается применение пробелов (Whitespace). IP-адреса представляются в формате [n.n.n.n], где n - десятичное число. Скобки являются опционными.</P>

<P ALIGN="JUSTIFY">Команды интерпретируются следующим образом:</P>

<P ALIGN="JUSTIFY"><B> Чтение статуса (1).</B> Поле данных команды пусто или содержит список идентификаторов, разделенных запятыми. Команда работает по-разному в зависимости от значения идентификатора. Если идентификатор не равен нулю, отклик содержит идентификатор партнера и статусное слово. Если идентификатор ассоциации равен нулю, отклик содержит системный идентификатор (0) и статусное слово, в то время как поле данных содержит список пар двоичных кодов:</P>

<P ALIGN="JUSTIFY"><идентификатор ассоциации> <статусное слово>,</P>

<P ALIGN="JUSTIFY">по одному на каждую, определенную в данный момент ассоциацию.</P>

<P ALIGN="JUSTIFY"><B>Чтение переменных (2). </B>Поле данных команды пусто или содержит список идентификаторов, разделенных запятыми. Если идентификатор ассоциации не равен нулю, отклик включает в себя идентификатор запрашиваемого партнера и его статусное слово, в то время как в поле данных записывается список переменных партнера и их значения. Если идентификатор ассоциации
равен нулю, поле данных содержит список системных переменных и их значения. Если партнер выбран в качестве источника синхронизации, отклик включает в себя идентификатор партнера и его статусное слово.</P>

<P ALIGN="JUSTIFY"><B>Запись переменных (3).</B> Поле данных команды содержит список присвоений, описанный выше. Отклик идентичен отклику на команду чтения переменных.</P>

<P ALIGN="JUSTIFY"><B>Чтение переменных часов (4).</B> Поле данных команды пусто или содержит список идентификаторов, разделенных запятыми. Идентификатор ассоциации выбирает переменные системных часов или партнера точно также, как в случае команды чтения переменных. Отклик включает в себя запрошенные идентификатор часов и статусное слово, а поле данных несет в себе список
переменных часов и их значений, включая последний временной код, полученный от часов.</P>

<P ALIGN="JUSTIFY"><B>Запись переменных часов (5).</B> Поле данных команды содержит список присвоений, как это описано выше. Отклик имеет формат, как в случае команду чтения переменных часов.</P>

<P ALIGN="JUSTIFY"><B>Установка адреса/порта Trap (6).</B> Идентификатор ассоциации команды, статус и поле данных игнорируются. Адрес и номер порта для последующих TRAP-сообщений берутся из самого управляющего сообщения. Исходное значение счетчика TRAP для сообщений откликов заимствуется из поля <I>номера по порядку</I>. Идентификатор ассоциации, статус и поле данных в отклике
несущественны.</P>

<P ALIGN="JUSTIFY"><B>Отклик на TRAP (7).</B> Это сообщение посылается, когда происходит событие (exception) в систему, у партнера или для данных часов. Код команды равен 7, а бит R=1. Содержимое trap-счетчика увеличивается на 1 для каждого сообщения данного типа. Поле <I>номер по порядку</I> сообщения равно содержимому этого счетчика. При посылке сообщения TRAP используется IP-адрес и
номер порта, заданные командой установки адреса и порта TRAP. В случае системного TRAP идентификатор ассоциации устанавливается равным нулю, а поле <I>статус</I> содержит статусное слово системы. В случае TRAP партнера поле идентификатора ассоциации соответствует партнеру, а поле <I>статус</I> несет в себе его статусное слово. В поле данных опционно может быть включено
любое символьное сообщение (ASCII).</P>

<P ALIGN="CENTER"><B><FONT SIZE=4> Приложение В. Аутентификация</P></B></FONT>

<P ALIGN="JUSTIFY">Требования надежности NTP подобны аналогичным для других протоколов, работающих с большим числом партнеров и служащих для маршрутизации, управления и доступа к файлам. Система должна противостоять случайным ошибкам и злонамеренным действиям.</P>

<P ALIGN="JUSTIFY">Механизм управления доступом в NTP отвечает всем базовым требованиям. Различные проверки препятствуют большинству возможных атак, связанных с подменой временных меток.</P>

<P ALIGN="JUSTIFY">Однако имеется возможность того, что хакер нарушит процедуру синхронизации путем модификации NTP-сообщений. Для подавления такой возможности нужно привлекать криптографические механизмы аутентификации (в частности сертификаты).</P>

<P ALIGN="JUSTIFY">Механизм, который работает на прикладном уровне, служит для того, чтобы исключить неавторизованную модификацию потока сообщений. Это достигается с помощью контрольных крипто-сумм, вычисляемых отправителем и проверяемых получателем. Однако сам протокол NTP не имеет средств для работы с сертификатами и ключами.</P>

<P ALIGN="JUSTIFY">Процедура вычисления контрольной крипто-суммы использует алгоритм DES (Data Encryption Standard) [NBS77].</P>

<P ALIGN="JUSTIFY"><B> Механизм аутентификации NTP</B> </P>

<P ALIGN="JUSTIFY">Когда предполагается использовать аутентификацию,
инициализируется ряд переменных, определяющих выбор сертификата, алгоритма шифрования и крипто-ключ и, возможно, другие параметры. Процедуры инициализации и выбора этих переменных не регламентируются протоколом NTP. Набор переменных партнера и пакетов может включать в себя следующие компоненты:</P>

<P ALIGN="JUSTIFY"><B> Бит разрешения аутентификации </B>(peer.authenable). Этот бит указывает, что ассоциация работает в режиме аутентификации. Для сконфигурированных партнеров этот бит определяется на фазе инициализации. Для неконфигурированных - этот бит делается равным 1, если приходящее сообщение содержит аутентификатор, в противном случае =0.</P>

<P ALIGN="JUSTIFY"><B> Бит аутентификации (peer.authentic).</B> Этот бит указывает, что последнее сообщение, полученное от партнера, было корректно аутентифицировано.</P>

<P ALIGN="JUSTIFY"><B> Идентификатор ключа </B>(peer.hostkeyid, peer.peerkeyid, pkt.keyid). Это целое число идентифицирует криптографический ключ, используемый для генерации кода аутентификации сообщения. Системная переменная peer.hostkeyid используется для активной ассоциации. Переменная peer.peerkeyid инициализируется нулем, когда ассоциация сформирована.</P>

<P ALIGN="JUSTIFY"><B> Криптографические ключи (sys.key).</B> Это набор 64-битовых ключей DES, где 7 младших бит каждого октета соответствуют битам 1-7 DES, а старший бит соответствует биту четности 8 (сумма нечетна).</P>

<P ALIGN="JUSTIFY"><B> Контрольная крипто-сумма (pkt.check).</B> Крипто-сумма вычисляется процедурой шифрования.</P>

<P ALIGN="JUSTIFY">Поле аутентификатора состоит из двух субполей, одно содержит переменную pkt.keyid, а другое переменную pkt.check, вычисленную программой шифрования, вызываемой процедурой передачи протокола NTP, а также программой дешифровки, которая вызывается процедурой приема NTP. Ее присутствия определяется по общей длине UDP-дейтограммы. Для целей аутентификации
NTP-сообщение дополняется нулями, для того чтобы сделать ее длину кратной 64 битам. Аутентификатор содержит 96 бит, куда входят 32-битовый идентификатор ключа и 64-битовая крипто-сумма. Дополнительная информация (например, о сертификате и алгоритме шифрования), если необходимо, может быть вставлена между NTP-сообщением и идентификатором ключа. Подобно аутентификатору эта
информация не включается в контрольное крипто-суммирование. </P>

<P ALIGN="JUSTIFY"><B> Процедуры аутентификации NTP</B> </P>

<P ALIGN="JUSTIFY">Когда используется аутентификация для реализации протокола NTP, привлекается две дополнительные процедуры. Одна из них формирует крипто-сумму для передаваемых сообщений, а другая дешифрует и проверяет корректность контрольной суммы получаемых сообщений. Процедуры представляют собой варианты программ, используемых для реализации алгоритма DES и описанных в [NBS80]. На самом деле процедура не связана жестко с алгоритмом DES, а лишь предполагают работу с 64-битовыми блоками данных.</P>

<P ALIGN="CENTER"><B><FONT SIZE=4> Приложение Г. Временная шкала NTP и ее хронометрия</B></FONT></P>

<P ALIGN="JUSTIFY">Ниже рассматривается соответствие временной шкалы NTP и UTC (Coordinated Universal Time). Синхронизация часов предполагает их согласование по частоте и времени.</P>

<P ALIGN="JUSTIFY">Для синхронизации необходимо уметь сравнить их частоты и показания. Базовыми источниками временных стандартов традиционно являлись периоды движения Земли, Луны и других космических объектов. К сожалению, они не слишком стабильны.</P>

<P ALIGN="JUSTIFY"><B> Первичная частота и стандарты времени</B> </P>

<P ALIGN="JUSTIFY">Первичными стандартами частоты являются осцилляторы с высокой стабильностью. Такие стандарты используют межуровневые переходы в атомах водорода, цезия и рубидия. В таблице <B>4.4.15.12</B> приведены характеристики типичных стандартов времени. Локальные же часы обычно
используют некомпенсированные кварцевые генераторы. Такие генераторы не только подвержены дрейфам под действием изменения параметров окружающей среды, но систематически меняют свои свойства со временем (старение).</P>

<P ALIGN="JUSTIFY">Даже если кварцевый генератор имеет температурную компенсацию, его частота должна время от времени сравниваться первичным стандартом для обеспечения высокой точности.</P>

<P ALIGN="JUSTIFY"><A NAME="PLESIO">Сеть, в которой все часы фазированы и согласованы по частоте с единым стандартом, называется изохронной. Сети, где разные часы сфазированы с разными стандартами, но все они привязаны к одной базовой частоте называются плезиохронными. В плезиохронных системах
фазы разных осцилляторов могут дрейфовать друг относительно друга, что может приводить к накоплению ошибок.</P>

<P ALIGN="JUSTIFY">Обычно часовые осцилляторы классифицируются по трем параметрам: стабильность, разброс и блуждание. Стабильность определяется систематическими вариациями частоты со временем. Синонимом нестабильности является старение и дрейф. Разброс (называемый также временным дрожанием)
характеризует кратковременные случайные вариации частоты с составляющими более 10 Гц, в то время как блуждание характеризует медленные вариации частоты с составляющими менее 10 Гц.</P>

<P ALIGN="CENTER">Таблица <B>4.4.15.12</B>. Точность и стабильность часов для различных слоев </P>

<P ALIGN="CENTER"><CENTER><TABLE BORDER=10 CELLSPACING=1 CELLPADDING=5 WIDTH=600 bgcolor="ghostwhite">
<TR><TD WIDTH="17%" VALIGN="TOP" bgcolor="gainsboro"><P ALIGN="CENTER">Слой</TD>
<TD WIDTH="39%" VALIGN="TOP" bgcolor="gainsboro"><P ALIGN="CENTER">Минимальная точность (за день)</TD>
<TD WIDTH="44%" VALIGN="TOP" bgcolor="gainsboro"><P ALIGN="LEFT">Минимальная стабильность (за день)</TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><P ALIGN="CENTER">1</TD>
<TD WIDTH="39%" VALIGN="TOP"><P ALIGN="CENTER">1 x 10<SUP>-11</SUP></TD>
<TD WIDTH="44%" VALIGN="TOP"><P ALIGN="JUSTIFY">Не специфицировано </TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><P ALIGN="CENTER">2</TD>
<TD WIDTH="39%" VALIGN="TOP"><P ALIGN="CENTER">1.6 x 10<SUP>-8</SUP></TD>
<TD WIDTH="44%" VALIGN="TOP"><P ALIGN="JUSTIFY">1 x 10<SUP>-10</SUP></TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><P ALIGN="CENTER">3</TD>
<TD WIDTH="39%" VALIGN="TOP"><P ALIGN="CENTER">4.6 x 10<SUP>-6</SUP></TD>
<TD WIDTH="44%" VALIGN="TOP"><P ALIGN="JUSTIFY">3.7 x 10<SUP>-7</SUP></TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP"><P ALIGN="CENTER">4</TD>
<TD WIDTH="39%" VALIGN="TOP"><P ALIGN="CENTER">3.2 x 10<SUP>-5</SUP></TD>
<TD WIDTH="44%" VALIGN="TOP"><P ALIGN="JUSTIFY">Не специфицировано</TD>
</TR>
</TABLE></CENTER></P>

<P ALIGN="JUSTIFY">Конструкция, работа и характеристики осциллятора слоя 1 предполагаются сопоставимыми с национальными стандартами времени и часто базируются на цезиевом стандарте. Часы слоя 4 соответствуют требованиям обычных цифровых каналов и систем PBX. Слои 2-3 могут использоваться для работы с мощными синхронными каналами связи.</P>

<P ALIGN="JUSTIFY"><B> Раздача времени и частоты</B> </P>

<P ALIGN="JUSTIFY">Для того чтобы атомное и обычное время могли быть взаимосвязаны, национальные администрации обеспечивают работу первичных стандартов времени и частоты и совместно координируют их функционирование. Большинство морских держав поддерживают широковещательные радиослужбы времени.</P>

<P ALIGN="JUSTIFY">Американский Национальный Институт Стандартов и Технологии (NIST – National Institute of Standards and Technology) поддерживает три радиослужбы для рассылки временной информации. Одна из них использует передачу (ВЧ или CCIR диапазон 7) на частотах 2.5, 5, 10, 15 и 20 Мгц. Сигнал распространяется, отражаясь от верхних слоев атмосферы, что неизбежно приводит к
непредсказуемым вариациям задержки на принимающей стороне. С 60-секундным интервалом передается временной код, который транслируется на 100 килогерцной субнесущей со скоростью передачи 1 бит/с. Этот код содержит информацию об UTC времени и дате, но не включает в себя данных о текущем годе и оповещения о добавлении/вычитании секунды для последней минуты данного дня. Существуют и другие сходные службы времени (например, в Оттаве), гарантирующие точность на уровне 1-10 мсек.</P>

<P ALIGN="JUSTIFY">Вторая служба времени NIST использует передачу (НЧ или CCIR диапазон 5) на частоте 60 КГц, она доступна на континентальной части США и вблизи берегов. Сигнал распространяется в нижней части атмосферы и по этой причине слабо подвержен вариациям времени распространения. Временной код передается с периодом в 60 секунд со скоростью 1 бит/с. Достижимая
точность составляет 50 миллисекунд [BLA74]. Ряд европейских стран предлагают аналогичные службы времени (Великобритания - MSF; Германия - DCF77). Коды времени здесь включают информацию о текущем годе и предупреждение о добавляемой/вычитаемой секунде. Третья служба NIST использует передачу на
частоте 468 МГц (УВЧ или CCIR диапазон 9) с геостационарных спутников GOES, три из которых перекрывают западное полушарие. Временной код перемежается с сообщениями, адресованными удаленным датчикам и состоит из 600 4-битовых слов, передаваемых с периодом в 30 секунд. Временной код содержит информацию об UTC времени-дне-годе, а также предупреждение о добавлении/вычитании секунды
в конце дня. Точность этой службы составляет 0,5 мсек.</P>

<P ALIGN="JUSTIFY">Министерство обороны США разработало глобальную систему определения координат GPS (Global Positioning System). Эта система базируется на 24 спутниках, движущихся по орбитам с периодом 12 часов. Система GPS может обеспечить точность определения времени на уровне нескольких наносекунд [VAN84].</P>

<P ALIGN="JUSTIFY">Американская береговая охрана в течение многих лет использует службу радионавигации LORAN-C [FRA82]. Эта служба обеспечивает временную точность менее 1 мксек.</P>

<P ALIGN="JUSTIFY">Система радионавигации военно-морского флота США и других стран OMEGA [VAS78] состоит из 8 передатчиков, работающих на частотах от 10.2 до 13.1 КГц (УНЧ или CIR диапазон 4) и перекрывающих весь земной шар 24 часа в сутки. Точность этой системы составляет около 1 мсек. Система OMEGA обеспечивает высокую точность для частоты, но не передает временного кода. По этой причине приемник должен предварительно получить географические координаты с точностью до градуса и время UTC с точностью 5 секунд от независимых источников.</P>

<P ALIGN="JUSTIFY">Заметим, что не все службы времени передают информацию о текущем годе и предупреждения о добавлении/вычитании секунды. Протокол NTP позволяет решить эту проблему.</P>

<P ALIGN="JUSTIFY"><B> Определение частоты</B> </P>

<P ALIGN="JUSTIFY">В течение многих лет наиболее важным использованием времени и частоты были всемирная навигация и космическая наука, которые зависят от наблюдений солнца, луны и звезд. За стандартную секунду (в 1957 году) принята 1/31,556,925.9747 периода вращения Земли вокруг Солнца (тропический год). Согласно этой шкалы тропический год длится 365.2421987 дней, а лунный месяц
29.53059 дней. Однако тропический год может быть определен лишь с точностью около 50 мсек.</P>

<P ALIGN="JUSTIFY">С древнейших времен человечеству были известны три осциллятора (процесса задающих временную шкалу) - вращение земли вокруг своей оси, вращение Луны вокруг Земли и вращение Земли вокруг Солнца. К сожалению, с точки требований современных технологий все эти три осциллятора не обладают достаточной стабильностью. В 1967 стандартная секунда была переопределена
и теперь равняется 9,192,631,770 периодов перехода в атоме цезия-133. С 1972 стандарты времени и частоты базируются на международном атомном времени TAI (International Atomic Time). Точность таких часов составляет около микросекунды в сутки. Важно то, что новая шкала абсолютно однородна и не подвержена дрейфам.</P>

<P ALIGN="JUSTIFY"><B> Определение времени и необходимости добавления/вычитания секунды</B> </P>

<P ALIGN="JUSTIFY">Международное бюро мер и стандартов IBWM (International Bureau of Weights and Measures) использует астрономические наблюдения, выполненные морской обсерваторией США и другими обсерваториями для определения UTC.</P>

<P ALIGN="JUSTIFY">Для более точной временной привязки событий после 1972 года необходимо знать, когда вставлялись или удалялись секунды коррекции (удаление пока никогда не производилось). Как определено в докладе 517 CCIR, который воспроизведен в [BLA74], дополнительные секунды вставляются после 23:59:59 в последний день июня или декабря. Неоднородность во временную шкалу (TAI) помимо
добавляемых секунд вносят также 100 миллисекундные коррекции UT1, называемые DUT1, которые служат для повышения точности при навигации. Следует признать, что момент добавления секунды является началом новой (однородной) временной шкалы.</P>

<P ALIGN="JUSTIFY">Временная шкала NTP базируется на шкале UTC, но необязательно всегда совпадает с ней. В 0 часов 1 января 1972 начинается эра UTC, часы NTP были установлены на 2,272,060,800 стандартных секунд после 0 часов 1 января 1900.</P>

<FONT SIZE=4><P ALIGN="CENTER"><B>Ссылки</P></B></FONT>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=5 WIDTH=800>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY"> [ABA89]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Abate, et al. AT&T's new approach to the synchronization of
telecommunication networks. IEEE Communications Magazine (April 1989), 35-45.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[ALL74a]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Allan, D.W., J.H. Shoaf and D. Halford. Statistics of time and frequency data
analysis. In: Blair, B.E. (Ed.). Time and Frequency Theory and Fundamentals. National Bureau of
Standards Monograph 140, U.S. Department of Commerce, 1974, 151-204.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[ALL74b]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Allan, D.W., J.E. Gray and H.E. Machlan. The National Bureau of Standards atomic time scale: generation, stability, accuracy and accessibility. In: Blair, B.E. (Ed.). Time and Frequency Theory and Fundamentals. National Bureau of Standards Monograph 140, U.S. Department of Commerce, 1974, 205-231.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[BEL86]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Bell Communications Research. Digital Synchronization Network Plan. Technical Advisory TA-NPL-000436, 1 November 1986.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[BER87]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Bertsekas, D., and R. Gallager. Data Networks. Prentice-Hall, Englewood Cliffs, NJ, 1987.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[BLA74]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Blair, B.E. Time and frequency dissemination: an overview of principles and techniques. In: Blair, B.E. (Ed.). Time and Frequency Theory and Fundamentals. National Bureau of Standards Monograph 140, U.S. Department of Commerce, 1974, 233-314.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[BRA80]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Braun, W.B. Short term frequency effects in networks of coupled oscillators. IEEE Trans. Communications COM-28, 8 (August 1980), 1269-1275</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[COL88]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Cole, R., and C. Foxcroft. An experiment in clock synchronisation. The Computer Journal 31, 6 (1988), 496-502.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[DAR81a]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Defense Advanced Research Projects Agency. Internet Protocol. DARPA Network Working Group Report RFC-791, USC Information Sciences Institute, September 1981.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[DAR81b]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Defense Advanced Research Projects Agency. Internet Control Message Protocol. DARPA Network Working Group Report RFC-792, USC Information Sciences Institute, September 1981.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[DEC89]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Digital Time Service Functional Specification Version T.1.0.5. Digital Equipment Corporation, 1989</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[DER90]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Dershowitz, N., and E.M. Reingold. Calendrical Calculations. Software Practice and Experience 20, 9 (September 1990), 899-928.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[FRA82]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Frank, R.L. History of LORAN-C. Navigation 29, 1 (Spring 1982).</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[GUS84]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Gusella, R., and S. Zatti. TEMPO - A network time controller for a distributed Berkeley UNIX system. IEEE Distributed Processing Technical Committee Newsletter 6, NoSI-2 (June 1984), 7-15. Also in: Proc. Summer USENIX Conference (June 1984, Salt Lake City).</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[GUS85a]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Gusella, R., and S. Zatti. The Berkeley UNIX 4.3BSD time synchronization protocol: protocol specification. Technical Report UCB/CSD 85/250, University of California, Berkeley, June 1985.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[GUS85b]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Gusella, R., and S. Zatti. An election algorithm for a distributed clock synchronization program. Technical Report UCB/CSD 86/275, University of California, Berkeley, December 1985.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[HAL84]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Halpern, J.Y., B. Simons, R. Strong and D. Dolly. Fault-tolerant clock synchronization. Proc. Third Annual ACM Symposium on Principles of Distributed Computing (August 1984), 89-102.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[JOR85]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Jordan, E.C. (Ed). Reference Data for Engineers, Seventh Edition. H.W. Sams & Co., New York, 1985.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[KOP87]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Kopetz, H., and W. Ochsenreiter. Clock synchronization in distributed real-time systems. IEEE Trans. Computers C-36, 8 (August 1987), 933-939.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[LAM78]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Lamport, L., Time, clocks and the ordering of events in a distributed system. Comm. ACM 21, 7 (July 1978), 558-565.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[LAM85]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Lamport, L., and P.M. Melliar-Smith. Synchronizing clocks in the presence of faults. J. ACM 32, 1 (January 1985), 52-78.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[LIN80]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Lindsay, W.C., and A.V. Kantak. Network synchronization of random signals. IEEE Trans. Communications COM-28, 8 (August 1980), 1260-1266.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[LUN84]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Lundelius, J., and N.A. Lynch. A new fault-tolerant algorithm for clock synchronization. Proc. Third Annual ACM Symposium on Principles of Distributed Computing (August 1984), 75-88.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[MAR85]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Marzullo, K., and S. Owicki. Maintaining the time in a distributed system. ACM Operating Systems Review 19, 3 (July 1985), 44-54.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[MIL81a]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Mills, D.L. Time Synchronization in DCNET Hosts. DARPA Internet Project Report IEN-173, COMSAT Laboratories, February 1981.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[MIL81b]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Mills, D.L. DCNET Internet Clock Service. DARPA Network Working Group Report RFC-778, COMSAT Laboratories, April 1981.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[MIL83a]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Mills, D.L. Internet Delay Experiments. DARPA Network Working Group Report RFC-889, M/A-COM Linkabit, December 1983.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[MIL83b]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Mills, D.L. DCN local-network protocols. DARPA Network Working Group Report RFC-891, M/A-COM Linkabit, December 1983.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[MIL85a]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Mills, D.L. Algorithms for synchronizing network clocks. DARPA Network Working Group Report RFC-956, M/A-COM Linkabit, September 1985.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[MIL85b]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Mills, D.L. Experiments in network clock synchronization. DARPA Network Working Group Report RFC-957, M/A-COM Linkabit, September 1985.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[MIL85c]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Mills, D.L. Network Time Protocol (NTP). DARPA Network Working Group Report RFC-958, M/A-COM Linkabit, September 1985.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[MIL88a]</TD>
<TD WIDTH="87%" VALIGN="TOP"><P ALIGN="JUSTIFY">Mills, D.L. Network Time Protocol (version 1) - specification and implementation. DARPA Network Working Group Report RFC-1059, University of Delaware, July 1988.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[MIL88b]</TD>
<TD WIDTH="87%" VALIGN="TOP"><P ALIGN="JUSTIFY">Mills, D.L. The Fuzzball. Proc. ACM SIGCOMM 88 Symposium (Palo Alto, CA, August 1988), 115-122.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[MIL89]</TD>
<TD WIDTH="87%" VALIGN="TOP"><P ALIGN="JUSTIFY">Mills, D.L. Network Time Protocol (version 2) - specification and implementation. DARPA Network Working Group Report RFC-1119, University of Delaware, September 1989.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[MIL90]</TD>
<TD WIDTH="87%" VALIGN="TOP"><P ALIGN="JUSTIFY">Mills, D.L. Measured performance of the Network Time Protocol in the Internet system. ACM Computer Communication Review 20, 1 (January 1990), 65-75.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[MIL91a]</TD>
<TD WIDTH="87%" VALIGN="TOP"><P ALIGN="JUSTIFY">Mills, D.L. Internet time synchronization: the Network Time Protocol. IEEE Trans. Communications 39, 10 (October 1991), 1482-1493.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[MIL91b]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Mills, D.L. On the chronology and metrology of computer network timescales and their application to the Network Time Protocol. ACM Computer Communications Review 21, 5 (October 1991), 8-17.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[MIT80]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Mitra, D. Network synchronization: analysis of a hybrid of master-slave and mutual synchronization. IEEE Trans. Communications COM-28, 8 (August 1980), 1245-1259.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[NBS77]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Data Encryption Standard. Federal Information Processing Standards Publication 46. National Bureau of Standards, U.S. Department of Commerce, 1977.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[NBS79]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Time and Frequency Dissemination Services. NBS Special Publication 432, U.S. Department of Commerce, 1979</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[NBS80]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">DES Modes of Operation. Federal Information Processing Standards Publication 81. National Bureau of Standards, U.S. Department of Commerce, December 1980.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[POS80]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Postel, J. User Datagram Protocol. DARPA Network Working Group Report RFC-768, USC Information Sciences Institute, August 1980.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[POS83a]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Postel, J. Daytime protocol. DARPA Network Working Group Report RFC-867, USC Information Sciences Institute, May 1983.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[POS83b]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Postel, J. Time protocol. DARPA Network Working Group Report RFC-868, USC Information Sciences Institute, May 1983.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[RIC88]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Rickert, N.W. Non Byzantine clock synchronization - a programming experiment. ACM Operating Systems Review 22, 1 (January 1988), 73-78.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[SCH86]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Schneider, F.B. A paradigm for reliable clock synchronization. Department of Computer Science Technical Report TR 86-735, Cornell University, February 1986.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[SMI86]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Smith, J. Modern Communications Circuits. McGraw-Hill, New York, NY, 1986.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[SRI87]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Srikanth, T.K., and S. Toueg. Optimal clock synchronization. J. ACM 34, 3 (July 1987), 626-645.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[STE88]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Steiner, J.G., C. Neuman, and J.I. Schiller. Kerberos: an authentication service for open network systems. Proc. Winter USENIX Conference (February 1988).</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[SU81]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Su, Z. A specification of the Internet protocol (IP) timestamp option. DARPA Network Working Group Report RFC-781. SRI International, May 1981.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[TRI86]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Tripathi, S.K., and S.H. Chang. ETempo: a clock synchronization algorithm for hierarchical LANs - implementation and measurements. Systems Research Center Technical Report TR-86-48, University of Maryland, 1986.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[VAN84]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Van Dierendonck, A.J., and W.C. Melton. Applications of time transfer using NAVSTAR GPS. In: Global Positioning System, Papers Published in Navigation, Vol. II, Institute of Navigation, Washington, DC, 1984.</TD>
</TR>
<TR><TD WIDTH="13%" VALIGN="TOP"><P ALIGN="JUSTIFY">[VAS78]</TD>
<TD WIDTH="87%" VALIGN="TOP">
<P ALIGN="JUSTIFY">Vass, E.R. OMEGA navigation system: present status and plans 1977-1980. Navigation 25, 1 (Spring 1978).</TD>
</TR>
</TABLE>












</TD></TR>

<TR bgcolor="steelblue"><TD VALIGN="TOP" bgcolor="steelblue" LINK="#0000FF"><P ALIGN="center">

<FONT color="white"><B> Previous: </B></FONT>
<A HREF="snd_mail.htm" tppabs="http://book.itep.ru/4/4/snd_mail.htm"><FONT COLOR="lightblue">4.4.14.5 Программа Sendmail</FONT></A>



<FONT color="white"><B> &nbsp; &nbsp;UP:</B></FONT>
<A HREF="rut_4411.htm" tppabs="http://book.itep.ru/4/44/rut_4411.htm"><FONT COLOR="lightblue">4.4.11 Протоколы    маршрутизации (обзор, таблицы маршрутизации, вектор расстояния)</FONT></A>


<BR>

<FONT color="white"><B>  Down:</B></FONT>
<A HREF="proc_45.htm" tppabs="http://book.itep.ru/4/45/proc_45.htm"><FONT COLOR="lightblue">4.5 Процедуры Интернет</FONT></A>



<FONT color="white"><B> &nbsp; &nbsp;Next:</B></FONT>
<A HREF="sntp4416.htm" tppabs="http://book.itep.ru/4/44/sntp4416.htm"><FONT COLOR="lightblue">4.4.16 Протокол SNTP</FONT></A>

</TD>
  </TR>
</table>
</BODY>
</HTML>